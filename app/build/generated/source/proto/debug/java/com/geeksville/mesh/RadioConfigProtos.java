// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: radioconfig.proto

package com.geeksville.mesh;

public final class RadioConfigProtos {
  private RadioConfigProtos() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  /**
   * <pre>
   * The frequency/regulatory region the user has selected.
   * Note: In 1.0 builds (which must still be supported by the android app for a
   * long time) this field will be unpopulated.
   * If firmware is ever upgraded from an old 1.0ish build, the old
   * MyNodeInfo.region string will be used to set UserPreferences.region and the
   * old value will be no longer set.
   * </pre>
   *
   * Protobuf enum {@code RegionCode}
   */
  public enum RegionCode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>Unset = 0;</code>
     */
    Unset(0),
    /**
     * <code>US = 1;</code>
     */
    US(1),
    /**
     * <code>EU433 = 2;</code>
     */
    EU433(2),
    /**
     * <code>EU865 = 3;</code>
     */
    EU865(3),
    /**
     * <code>CN = 4;</code>
     */
    CN(4),
    /**
     * <code>JP = 5;</code>
     */
    JP(5),
    /**
     * <code>ANZ = 6;</code>
     */
    ANZ(6),
    /**
     * <code>KR = 7;</code>
     */
    KR(7),
    /**
     * <code>TW = 8;</code>
     */
    TW(8),
    /**
     * <code>RU = 9;</code>
     */
    RU(9),
    UNRECOGNIZED(-1),
    ;

    /**
     * <code>Unset = 0;</code>
     */
    public static final int Unset_VALUE = 0;
    /**
     * <code>US = 1;</code>
     */
    public static final int US_VALUE = 1;
    /**
     * <code>EU433 = 2;</code>
     */
    public static final int EU433_VALUE = 2;
    /**
     * <code>EU865 = 3;</code>
     */
    public static final int EU865_VALUE = 3;
    /**
     * <code>CN = 4;</code>
     */
    public static final int CN_VALUE = 4;
    /**
     * <code>JP = 5;</code>
     */
    public static final int JP_VALUE = 5;
    /**
     * <code>ANZ = 6;</code>
     */
    public static final int ANZ_VALUE = 6;
    /**
     * <code>KR = 7;</code>
     */
    public static final int KR_VALUE = 7;
    /**
     * <code>TW = 8;</code>
     */
    public static final int TW_VALUE = 8;
    /**
     * <code>RU = 9;</code>
     */
    public static final int RU_VALUE = 9;


    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static RegionCode valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static RegionCode forNumber(int value) {
      switch (value) {
        case 0: return Unset;
        case 1: return US;
        case 2: return EU433;
        case 3: return EU865;
        case 4: return CN;
        case 5: return JP;
        case 6: return ANZ;
        case 7: return KR;
        case 8: return TW;
        case 9: return RU;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<RegionCode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        RegionCode> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<RegionCode>() {
            public RegionCode findValueByNumber(int number) {
              return RegionCode.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.geeksville.mesh.RadioConfigProtos.getDescriptor().getEnumTypes().get(0);
    }

    private static final RegionCode[] VALUES = values();

    public static RegionCode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private RegionCode(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:RegionCode)
  }

  /**
   * <pre>
   * Sets the charge control current of devices with a battery charger that can be
   * configured. This is passed into the axp power management chip like on the tbeam.
   * </pre>
   *
   * Protobuf enum {@code ChargeCurrent}
   */
  public enum ChargeCurrent
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>MAUnset = 0;</code>
     */
    MAUnset(0),
    /**
     * <code>MA100 = 1;</code>
     */
    MA100(1),
    /**
     * <code>MA190 = 2;</code>
     */
    MA190(2),
    /**
     * <code>MA280 = 3;</code>
     */
    MA280(3),
    /**
     * <code>MA360 = 4;</code>
     */
    MA360(4),
    /**
     * <code>MA450 = 5;</code>
     */
    MA450(5),
    /**
     * <code>MA550 = 6;</code>
     */
    MA550(6),
    /**
     * <code>MA630 = 7;</code>
     */
    MA630(7),
    /**
     * <code>MA700 = 8;</code>
     */
    MA700(8),
    /**
     * <code>MA780 = 9;</code>
     */
    MA780(9),
    /**
     * <code>MA880 = 10;</code>
     */
    MA880(10),
    /**
     * <code>MA960 = 11;</code>
     */
    MA960(11),
    /**
     * <code>MA1000 = 12;</code>
     */
    MA1000(12),
    /**
     * <code>MA1080 = 13;</code>
     */
    MA1080(13),
    /**
     * <code>MA1160 = 14;</code>
     */
    MA1160(14),
    /**
     * <code>MA1240 = 15;</code>
     */
    MA1240(15),
    /**
     * <code>MA1320 = 16;</code>
     */
    MA1320(16),
    UNRECOGNIZED(-1),
    ;

    /**
     * <code>MAUnset = 0;</code>
     */
    public static final int MAUnset_VALUE = 0;
    /**
     * <code>MA100 = 1;</code>
     */
    public static final int MA100_VALUE = 1;
    /**
     * <code>MA190 = 2;</code>
     */
    public static final int MA190_VALUE = 2;
    /**
     * <code>MA280 = 3;</code>
     */
    public static final int MA280_VALUE = 3;
    /**
     * <code>MA360 = 4;</code>
     */
    public static final int MA360_VALUE = 4;
    /**
     * <code>MA450 = 5;</code>
     */
    public static final int MA450_VALUE = 5;
    /**
     * <code>MA550 = 6;</code>
     */
    public static final int MA550_VALUE = 6;
    /**
     * <code>MA630 = 7;</code>
     */
    public static final int MA630_VALUE = 7;
    /**
     * <code>MA700 = 8;</code>
     */
    public static final int MA700_VALUE = 8;
    /**
     * <code>MA780 = 9;</code>
     */
    public static final int MA780_VALUE = 9;
    /**
     * <code>MA880 = 10;</code>
     */
    public static final int MA880_VALUE = 10;
    /**
     * <code>MA960 = 11;</code>
     */
    public static final int MA960_VALUE = 11;
    /**
     * <code>MA1000 = 12;</code>
     */
    public static final int MA1000_VALUE = 12;
    /**
     * <code>MA1080 = 13;</code>
     */
    public static final int MA1080_VALUE = 13;
    /**
     * <code>MA1160 = 14;</code>
     */
    public static final int MA1160_VALUE = 14;
    /**
     * <code>MA1240 = 15;</code>
     */
    public static final int MA1240_VALUE = 15;
    /**
     * <code>MA1320 = 16;</code>
     */
    public static final int MA1320_VALUE = 16;


    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static ChargeCurrent valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static ChargeCurrent forNumber(int value) {
      switch (value) {
        case 0: return MAUnset;
        case 1: return MA100;
        case 2: return MA190;
        case 3: return MA280;
        case 4: return MA360;
        case 5: return MA450;
        case 6: return MA550;
        case 7: return MA630;
        case 8: return MA700;
        case 9: return MA780;
        case 10: return MA880;
        case 11: return MA960;
        case 12: return MA1000;
        case 13: return MA1080;
        case 14: return MA1160;
        case 15: return MA1240;
        case 16: return MA1320;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<ChargeCurrent>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        ChargeCurrent> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<ChargeCurrent>() {
            public ChargeCurrent findValueByNumber(int number) {
              return ChargeCurrent.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.geeksville.mesh.RadioConfigProtos.getDescriptor().getEnumTypes().get(1);
    }

    private static final ChargeCurrent[] VALUES = values();

    public static ChargeCurrent valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private ChargeCurrent(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:ChargeCurrent)
  }

  /**
   * <pre>
   * How the GPS hardware in this unit is operated.
   * Note: This is independent of how our location is shared with other devices.
   * For that see LocationSharing
   * </pre>
   *
   * Protobuf enum {@code GpsOperation}
   */
  public enum GpsOperation
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <pre>
     * This is treated as GpsOpMobile - it is the default setting
     * </pre>
     *
     * <code>GpsOpUnset = 0;</code>
     */
    GpsOpUnset(0),
    /**
     * <pre>
     * Note: This mode was removed, because it is identical go GpsOpMobile with a gps_update_rate of once per day
     * This node is mostly stationary, we should try to get location only once per day,
     * Once we have that position we should turn the GPS to sleep mode
     * This is the recommended configuration for stationary 'router' nodes
     * </pre>
     *
     * <code>GpsOpStationary = 1;</code>
     */
    GpsOpStationary(1),
    /**
     * <pre>
     * This node is mobile and we should get GPS position at a rate governed by gps_update_rate
     * </pre>
     *
     * <code>GpsOpMobile = 2;</code>
     */
    GpsOpMobile(2),
    /**
     * <pre>
     * We should only use the GPS to get time (no location data should be acquired/stored)
     * Once we have the time we treat gps_update_interval as MAXINT (i.e. sleep forever)
     * </pre>
     *
     * <code>GpsOpTimeOnly = 3;</code>
     */
    GpsOpTimeOnly(3),
    /**
     * <pre>
     * GPS is always turned off - this mode is not recommended - use GpsOpTimeOnly instead
     * </pre>
     *
     * <code>GpsOpDisabled = 4;</code>
     */
    GpsOpDisabled(4),
    UNRECOGNIZED(-1),
    ;

    /**
     * <pre>
     * This is treated as GpsOpMobile - it is the default setting
     * </pre>
     *
     * <code>GpsOpUnset = 0;</code>
     */
    public static final int GpsOpUnset_VALUE = 0;
    /**
     * <pre>
     * Note: This mode was removed, because it is identical go GpsOpMobile with a gps_update_rate of once per day
     * This node is mostly stationary, we should try to get location only once per day,
     * Once we have that position we should turn the GPS to sleep mode
     * This is the recommended configuration for stationary 'router' nodes
     * </pre>
     *
     * <code>GpsOpStationary = 1;</code>
     */
    public static final int GpsOpStationary_VALUE = 1;
    /**
     * <pre>
     * This node is mobile and we should get GPS position at a rate governed by gps_update_rate
     * </pre>
     *
     * <code>GpsOpMobile = 2;</code>
     */
    public static final int GpsOpMobile_VALUE = 2;
    /**
     * <pre>
     * We should only use the GPS to get time (no location data should be acquired/stored)
     * Once we have the time we treat gps_update_interval as MAXINT (i.e. sleep forever)
     * </pre>
     *
     * <code>GpsOpTimeOnly = 3;</code>
     */
    public static final int GpsOpTimeOnly_VALUE = 3;
    /**
     * <pre>
     * GPS is always turned off - this mode is not recommended - use GpsOpTimeOnly instead
     * </pre>
     *
     * <code>GpsOpDisabled = 4;</code>
     */
    public static final int GpsOpDisabled_VALUE = 4;


    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static GpsOperation valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static GpsOperation forNumber(int value) {
      switch (value) {
        case 0: return GpsOpUnset;
        case 1: return GpsOpStationary;
        case 2: return GpsOpMobile;
        case 3: return GpsOpTimeOnly;
        case 4: return GpsOpDisabled;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<GpsOperation>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        GpsOperation> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<GpsOperation>() {
            public GpsOperation findValueByNumber(int number) {
              return GpsOperation.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.geeksville.mesh.RadioConfigProtos.getDescriptor().getEnumTypes().get(2);
    }

    private static final GpsOperation[] VALUES = values();

    public static GpsOperation valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private GpsOperation(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:GpsOperation)
  }

  /**
   * <pre>
   * How our location is shared with other nodes (or the local phone)
   * </pre>
   *
   * Protobuf enum {@code LocationSharing}
   */
  public enum LocationSharing
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <pre>
     * This is the default and treated as LocEnabled.
     * </pre>
     *
     * <code>LocUnset = 0;</code>
     */
    LocUnset(0),
    /**
     * <pre>
     * We are sharing our location
     * </pre>
     *
     * <code>LocEnabled = 1;</code>
     */
    LocEnabled(1),
    /**
     * <pre>
     * We are not sharing our location (if the unit has a GPS it will default to only get time - i.e. GpsOpTimeOnly)
     * </pre>
     *
     * <code>LocDisabled = 2;</code>
     */
    LocDisabled(2),
    UNRECOGNIZED(-1),
    ;

    /**
     * <pre>
     * This is the default and treated as LocEnabled.
     * </pre>
     *
     * <code>LocUnset = 0;</code>
     */
    public static final int LocUnset_VALUE = 0;
    /**
     * <pre>
     * We are sharing our location
     * </pre>
     *
     * <code>LocEnabled = 1;</code>
     */
    public static final int LocEnabled_VALUE = 1;
    /**
     * <pre>
     * We are not sharing our location (if the unit has a GPS it will default to only get time - i.e. GpsOpTimeOnly)
     * </pre>
     *
     * <code>LocDisabled = 2;</code>
     */
    public static final int LocDisabled_VALUE = 2;


    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static LocationSharing valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static LocationSharing forNumber(int value) {
      switch (value) {
        case 0: return LocUnset;
        case 1: return LocEnabled;
        case 2: return LocDisabled;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<LocationSharing>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        LocationSharing> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<LocationSharing>() {
            public LocationSharing findValueByNumber(int number) {
              return LocationSharing.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.geeksville.mesh.RadioConfigProtos.getDescriptor().getEnumTypes().get(3);
    }

    private static final LocationSharing[] VALUES = values();

    public static LocationSharing valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private LocationSharing(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:LocationSharing)
  }

  public interface RadioConfigOrBuilder extends
      // @@protoc_insertion_point(interface_extends:RadioConfig)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>.RadioConfig.UserPreferences preferences = 1;</code>
     * @return Whether the preferences field is set.
     */
    boolean hasPreferences();
    /**
     * <code>.RadioConfig.UserPreferences preferences = 1;</code>
     * @return The preferences.
     */
    com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences getPreferences();
    /**
     * <code>.RadioConfig.UserPreferences preferences = 1;</code>
     */
    com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferencesOrBuilder getPreferencesOrBuilder();
  }
  /**
   * <pre>
   * The entire set of user settable/readable settings for our radio device.
   * Includes both the current channel settings and any preferences the user has
   * set for behavior of their node
   * </pre>
   *
   * Protobuf type {@code RadioConfig}
   */
  public static final class RadioConfig extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:RadioConfig)
      RadioConfigOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use RadioConfig.newBuilder() to construct.
    private RadioConfig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private RadioConfig() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new RadioConfig();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private RadioConfig(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences.Builder subBuilder = null;
              if (preferences_ != null) {
                subBuilder = preferences_.toBuilder();
              }
              preferences_ = input.readMessage(com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(preferences_);
                preferences_ = subBuilder.buildPartial();
              }

              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.geeksville.mesh.RadioConfigProtos.internal_static_RadioConfig_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.geeksville.mesh.RadioConfigProtos.internal_static_RadioConfig_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.geeksville.mesh.RadioConfigProtos.RadioConfig.class, com.geeksville.mesh.RadioConfigProtos.RadioConfig.Builder.class);
    }

    public interface UserPreferencesOrBuilder extends
        // @@protoc_insertion_point(interface_extends:RadioConfig.UserPreferences)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <pre>
       * We should send our position this often (but only if it has changed significantly)
       * Defaults to 15 minutes
       * </pre>
       *
       * <code>uint32 position_broadcast_secs = 1;</code>
       * @return The positionBroadcastSecs.
       */
      int getPositionBroadcastSecs();

      /**
       * <pre>
       * Send our owner info at least this often (also we always send once at boot - to rejoin the mesh)
       * </pre>
       *
       * <code>uint32 send_owner_interval = 2;</code>
       * @return The sendOwnerInterval.
       */
      int getSendOwnerInterval();

      /**
       * <pre>
       * Power management state machine option.
       * See [power management](/software/other/power.md) for details.
       * 0 for default of 1 minute
       * </pre>
       *
       * <code>uint32 wait_bluetooth_secs = 4;</code>
       * @return The waitBluetoothSecs.
       */
      int getWaitBluetoothSecs();

      /**
       * <pre>
       * Power management state machine option.
       * See [power management](/software/other/power.md) for details.
       * 0 for default of one minute
       * </pre>
       *
       * <code>uint32 screen_on_secs = 5;</code>
       * @return The screenOnSecs.
       */
      int getScreenOnSecs();

      /**
       * <pre>
       * Power management state machine option.
       * See [power management](/software/other/power.md) for details.
       * 0 for default of 15 minutes
       * IMPORTANT NOTE FOR DEVICE CLIENTS: YOU MUST SEND SOME SORT OF PACKET TO THE PHONE AT LEAST THIS OFTEN OR THE DEVICE WILL DECIDE YOU ARE GONE!
       * </pre>
       *
       * <code>uint32 phone_timeout_secs = 6;</code>
       * @return The phoneTimeoutSecs.
       */
      int getPhoneTimeoutSecs();

      /**
       * <pre>
       * Power management state machine option.
       * See [power management](/software/other/power.md) for details.
       * 0 for default of two hours, MAXUINT for disabled
       * </pre>
       *
       * <code>uint32 phone_sds_timeout_sec = 7;</code>
       * @return The phoneSdsTimeoutSec.
       */
      int getPhoneSdsTimeoutSec();

      /**
       * <pre>
       * Power management state machine option.
       * See [power management](/software/other/power.md) for details.
       * 0 for default of two hours, MAXUINT for disabled
       * </pre>
       *
       * <code>uint32 mesh_sds_timeout_secs = 8;</code>
       * @return The meshSdsTimeoutSecs.
       */
      int getMeshSdsTimeoutSecs();

      /**
       * <pre>
       * Power management state machine option.
       * See [power management](/software/other/power.md) for details.
       * 0 for default of one year
       * </pre>
       *
       * <code>uint32 sds_secs = 9;</code>
       * @return The sdsSecs.
       */
      int getSdsSecs();

      /**
       * <pre>
       * Power management state machine option.
       * See [power management](/software/other/power.md) for details.
       * 0 for default of 3600
       * </pre>
       *
       * <code>uint32 ls_secs = 10;</code>
       * @return The lsSecs.
       */
      int getLsSecs();

      /**
       * <pre>
       * Power management state machine option.
       * See [power management](/software/other/power.md) for details.
       * 0 for default of 10 seconds
       * </pre>
       *
       * <code>uint32 min_wake_secs = 11;</code>
       * @return The minWakeSecs.
       */
      int getMinWakeSecs();

      /**
       * <pre>
       * If set, this node will try to join the specified wifi network and
       * acquire an address via DHCP
       * </pre>
       *
       * <code>string wifi_ssid = 12;</code>
       * @return The wifiSsid.
       */
      java.lang.String getWifiSsid();
      /**
       * <pre>
       * If set, this node will try to join the specified wifi network and
       * acquire an address via DHCP
       * </pre>
       *
       * <code>string wifi_ssid = 12;</code>
       * @return The bytes for wifiSsid.
       */
      com.google.protobuf.ByteString
          getWifiSsidBytes();

      /**
       * <pre>
       * If set, will be use to authenticate to the named wifi
       * </pre>
       *
       * <code>string wifi_password = 13;</code>
       * @return The wifiPassword.
       */
      java.lang.String getWifiPassword();
      /**
       * <pre>
       * If set, will be use to authenticate to the named wifi
       * </pre>
       *
       * <code>string wifi_password = 13;</code>
       * @return The bytes for wifiPassword.
       */
      com.google.protobuf.ByteString
          getWifiPasswordBytes();

      /**
       * <pre>
       * If set, the node will operate as an AP (and DHCP server), otherwise it
       * will be a station
       * </pre>
       *
       * <code>bool wifi_ap_mode = 14;</code>
       * @return The wifiApMode.
       */
      boolean getWifiApMode();

      /**
       * <pre>
       * The region code for my radio (US, CN, EU433, etc...)
       * </pre>
       *
       * <code>.RegionCode region = 15;</code>
       * @return The enum numeric value on the wire for region.
       */
      int getRegionValue();
      /**
       * <pre>
       * The region code for my radio (US, CN, EU433, etc...)
       * </pre>
       *
       * <code>.RegionCode region = 15;</code>
       * @return The region.
       */
      com.geeksville.mesh.RadioConfigProtos.RegionCode getRegion();

      /**
       * <pre>
       * Sets the current of the battery charger
       * </pre>
       *
       * <code>.ChargeCurrent charge_current = 16;</code>
       * @return The enum numeric value on the wire for chargeCurrent.
       */
      int getChargeCurrentValue();
      /**
       * <pre>
       * Sets the current of the battery charger
       * </pre>
       *
       * <code>.ChargeCurrent charge_current = 16;</code>
       * @return The chargeCurrent.
       */
      com.geeksville.mesh.RadioConfigProtos.ChargeCurrent getChargeCurrent();

      /**
       * <pre>
       * Are we operating as a router.
       * Changes behavior in the following ways:
       * The device will only sleep for critically low battery level (i.e. always tries to stay alive for the mesh)
       * In the future routing decisions will preferentially route packets through nodes with this attribute (because assumed
       * good line of sight)
       * </pre>
       *
       * <code>bool is_router = 37;</code>
       * @return The isRouter.
       */
      boolean getIsRouter();

      /**
       * <pre>
       * If set, we are powered from a low-current source (i.e. solar), so even if it looks like we have power flowing in
       * we should try to minimize power consumption as much as possible.
       * YOU DO NOT NEED TO SET THIS IF YOU'VE set is_router (it is implied in that case).
       * </pre>
       *
       * <code>bool is_low_power = 38;</code>
       * @return The isLowPower.
       */
      boolean getIsLowPower();

      /**
       * <pre>
       * If set, this node is at a fixed position.
       * We will generate GPS position updates at the regular interval, but use whatever the last lat/lon/alt we have for the node.
       * The lat/lon/alt can be set by an internal GPS or with the help of the app.
       * </pre>
       *
       * <code>bool fixed_position = 39;</code>
       * @return The fixedPosition.
       */
      boolean getFixedPosition();

      /**
       * <pre>
       * If set, this will disable the SerialConsole by not initilizing the StreamAPI
       * </pre>
       *
       * <code>bool serial_disabled = 40;</code>
       * @return The serialDisabled.
       */
      boolean getSerialDisabled();

      /**
       * <pre>
       * How our location is shared with other nodes (or the local phone)
       * </pre>
       *
       * <code>.LocationSharing location_share = 32;</code>
       * @return The enum numeric value on the wire for locationShare.
       */
      int getLocationShareValue();
      /**
       * <pre>
       * How our location is shared with other nodes (or the local phone)
       * </pre>
       *
       * <code>.LocationSharing location_share = 32;</code>
       * @return The locationShare.
       */
      com.geeksville.mesh.RadioConfigProtos.LocationSharing getLocationShare();

      /**
       * <pre>
       * How the GPS hardware in this unit is operated.
       * Note: This is independent of how our location is shared with other devices.
       * For that see LocationSharing
       * </pre>
       *
       * <code>.GpsOperation gps_operation = 33;</code>
       * @return The enum numeric value on the wire for gpsOperation.
       */
      int getGpsOperationValue();
      /**
       * <pre>
       * How the GPS hardware in this unit is operated.
       * Note: This is independent of how our location is shared with other devices.
       * For that see LocationSharing
       * </pre>
       *
       * <code>.GpsOperation gps_operation = 33;</code>
       * @return The gpsOperation.
       */
      com.geeksville.mesh.RadioConfigProtos.GpsOperation getGpsOperation();

      /**
       * <pre>
       * How often should we try to get GPS position (in seconds) when we are in GpsOpMobile mode?
       * or zero for the default of once every 30 seconds
       * or a very large value (maxint) to update only once at boot.
       * </pre>
       *
       * <code>uint32 gps_update_interval = 34;</code>
       * @return The gpsUpdateInterval.
       */
      int getGpsUpdateInterval();

      /**
       * <pre>
       * How long should we try to get our position during each gps_update_interval attempt?  (in seconds)
       * Or if zero, use the default of 30 seconds.
       * If we don't get a new gps fix in that time, the gps will be put into sleep until  the next gps_update_rate
       * window. 
       * </pre>
       *
       * <code>uint32 gps_attempt_time = 36;</code>
       * @return The gpsAttemptTime.
       */
      int getGpsAttemptTime();

      /**
       * <pre>
       * This parameter is for advanced users with advanced test equipment, we do not recommend most users use it.
       * A frequency offset that is added to to the calculated band center frequency.
       * Used to correct for crystal calibration errors.
       * </pre>
       *
       * <code>float frequency_offset = 41;</code>
       * @return The frequencyOffset.
       */
      float getFrequencyOffset();

      /**
       * <pre>
       * The server to use for our MQTT global message gateway feature.
       * If not set, the default server will be used 
       * </pre>
       *
       * <code>string mqtt_server = 42;</code>
       * @return The mqttServer.
       */
      java.lang.String getMqttServer();
      /**
       * <pre>
       * The server to use for our MQTT global message gateway feature.
       * If not set, the default server will be used 
       * </pre>
       *
       * <code>string mqtt_server = 42;</code>
       * @return The bytes for mqttServer.
       */
      com.google.protobuf.ByteString
          getMqttServerBytes();

      /**
       * <pre>
       * If a meshtastic node is able to reach the internet it will normally attempt to gateway any channels that are marked as
       * is_uplink_enabled or is_downlink_enabled.
       * But if this flag is set, all MQTT features will be disabled and no servers will be contacted.
       * </pre>
       *
       * <code>bool mqtt_disabled = 43;</code>
       * @return The mqttDisabled.
       */
      boolean getMqttDisabled();

      /**
       * <pre>
       * This setting is never saved to disk, but if set, all device settings will be returned to factory defaults.
       * (Region, serial number etc... will be preserved)
       * </pre>
       *
       * <code>bool factory_reset = 100;</code>
       * @return The factoryReset.
       */
      boolean getFactoryReset();

      /**
       * <pre>
       * By default we turn off logging as soon as an API client connects (to keep shared serial link quiet).
       * Set this to true to leave the debug log outputting even when API is active.
       * </pre>
       *
       * <code>bool debug_log_enabled = 101;</code>
       * @return The debugLogEnabled.
       */
      boolean getDebugLogEnabled();

      /**
       * <pre>
       * If true, radio should not try to be smart about what packets to queue to
       * the phone
       * bool keep_all_packets = 101;
       * If true, we will try to capture all the packets sent on the mesh, not just the ones destined to our node.
       * bool promiscuous_mode = 102;
       * For testing it is useful sometimes to force a node to never listen to
       * particular other nodes (simulating radio out of range). All nodenums listed
       * in ignore_incoming will have packets they send droped on receive (by router.cpp)
       * </pre>
       *
       * <code>repeated uint32 ignore_incoming = 103;</code>
       * @return A list containing the ignoreIncoming.
       */
      java.util.List<java.lang.Integer> getIgnoreIncomingList();
      /**
       * <pre>
       * If true, radio should not try to be smart about what packets to queue to
       * the phone
       * bool keep_all_packets = 101;
       * If true, we will try to capture all the packets sent on the mesh, not just the ones destined to our node.
       * bool promiscuous_mode = 102;
       * For testing it is useful sometimes to force a node to never listen to
       * particular other nodes (simulating radio out of range). All nodenums listed
       * in ignore_incoming will have packets they send droped on receive (by router.cpp)
       * </pre>
       *
       * <code>repeated uint32 ignore_incoming = 103;</code>
       * @return The count of ignoreIncoming.
       */
      int getIgnoreIncomingCount();
      /**
       * <pre>
       * If true, radio should not try to be smart about what packets to queue to
       * the phone
       * bool keep_all_packets = 101;
       * If true, we will try to capture all the packets sent on the mesh, not just the ones destined to our node.
       * bool promiscuous_mode = 102;
       * For testing it is useful sometimes to force a node to never listen to
       * particular other nodes (simulating radio out of range). All nodenums listed
       * in ignore_incoming will have packets they send droped on receive (by router.cpp)
       * </pre>
       *
       * <code>repeated uint32 ignore_incoming = 103;</code>
       * @param index The index of the element to return.
       * @return The ignoreIncoming at the given index.
       */
      int getIgnoreIncoming(int index);

      /**
       * <pre>
       * Preferences for the SerialPlugin
       * FIXME - Move this out of UserPreferences and into a section for plugin configuration.
       * </pre>
       *
       * <code>bool serialplugin_enabled = 120;</code>
       * @return The serialpluginEnabled.
       */
      boolean getSerialpluginEnabled();

      /**
       * <code>bool serialplugin_echo = 121;</code>
       * @return The serialpluginEcho.
       */
      boolean getSerialpluginEcho();

      /**
       * <code>uint32 serialplugin_rxd = 122;</code>
       * @return The serialpluginRxd.
       */
      int getSerialpluginRxd();

      /**
       * <code>uint32 serialplugin_txd = 123;</code>
       * @return The serialpluginTxd.
       */
      int getSerialpluginTxd();

      /**
       * <code>uint32 serialplugin_timeout = 124;</code>
       * @return The serialpluginTimeout.
       */
      int getSerialpluginTimeout();

      /**
       * <code>uint32 serialplugin_mode = 125;</code>
       * @return The serialpluginMode.
       */
      int getSerialpluginMode();

      /**
       * <pre>
       * Preferences for the ExternalNotificationPlugin
       * FIXME - Move this out of UserPreferences and into a section for plugin configuration.
       * </pre>
       *
       * <code>bool ext_notification_plugin_enabled = 126;</code>
       * @return The extNotificationPluginEnabled.
       */
      boolean getExtNotificationPluginEnabled();

      /**
       * <code>uint32 ext_notification_plugin_output_ms = 127;</code>
       * @return The extNotificationPluginOutputMs.
       */
      int getExtNotificationPluginOutputMs();

      /**
       * <code>uint32 ext_notification_plugin_output = 128;</code>
       * @return The extNotificationPluginOutput.
       */
      int getExtNotificationPluginOutput();

      /**
       * <code>bool ext_notification_plugin_active = 129;</code>
       * @return The extNotificationPluginActive.
       */
      boolean getExtNotificationPluginActive();

      /**
       * <code>bool ext_notification_plugin_alert_message = 130;</code>
       * @return The extNotificationPluginAlertMessage.
       */
      boolean getExtNotificationPluginAlertMessage();

      /**
       * <code>bool ext_notification_plugin_alert_bell = 131;</code>
       * @return The extNotificationPluginAlertBell.
       */
      boolean getExtNotificationPluginAlertBell();

      /**
       * <pre>
       *Preferences for the RangeTestPlugin
       * FIXME - Move this out of UserPreferences and into a section for plugin configuration.
       * </pre>
       *
       * <code>bool range_test_plugin_enabled = 132;</code>
       * @return The rangeTestPluginEnabled.
       */
      boolean getRangeTestPluginEnabled();

      /**
       * <code>uint32 range_test_plugin_sender = 133;</code>
       * @return The rangeTestPluginSender.
       */
      int getRangeTestPluginSender();

      /**
       * <code>bool range_test_plugin_save = 134;</code>
       * @return The rangeTestPluginSave.
       */
      boolean getRangeTestPluginSave();

      /**
       * <pre>
       * Preferences for the StoreForwardPlugin
       *FIXME - Move this out of UserPreferences and into a section for plugin configuration. (was 136)
       * </pre>
       *
       * <code>bool store_forward_plugin_enabled = 148;</code>
       * @return The storeForwardPluginEnabled.
       */
      boolean getStoreForwardPluginEnabled();

      /**
       * <code>uint32 store_forward_plugin_records = 137;</code>
       * @return The storeForwardPluginRecords.
       */
      int getStoreForwardPluginRecords();

      /**
       * <pre>
       * Preferences for the EnvironmentalMeasurement Plugin
       * FIXME - Move this out of UserPreferences and into a section for plugin configuration.
       * Enable/Disable the environmental measurement plugin measurement collection
       * </pre>
       *
       * <code>bool environmental_measurement_plugin_measurement_enabled = 140;</code>
       * @return The environmentalMeasurementPluginMeasurementEnabled.
       */
      boolean getEnvironmentalMeasurementPluginMeasurementEnabled();

      /**
       * <pre>
       * Enable/Disable the environmental measurement plugin on-device display
       * </pre>
       *
       * <code>bool environmental_measurement_plugin_screen_enabled = 141;</code>
       * @return The environmentalMeasurementPluginScreenEnabled.
       */
      boolean getEnvironmentalMeasurementPluginScreenEnabled();

      /**
       * <pre>
       * Sometimes sensor reads can fail.
       * If this happens, we will retry a configurable number of attempts,
       * each attempt will be delayed by the minimum required refresh rate for that sensor
       * </pre>
       *
       * <code>uint32 environmental_measurement_plugin_read_error_count_threshold = 142;</code>
       * @return The environmentalMeasurementPluginReadErrorCountThreshold.
       */
      int getEnvironmentalMeasurementPluginReadErrorCountThreshold();

      /**
       * <pre>
       * Interval in seconds of how often we should try to send our 
       * measurements to the mesh
       * </pre>
       *
       * <code>uint32 environmental_measurement_plugin_update_interval = 143;</code>
       * @return The environmentalMeasurementPluginUpdateInterval.
       */
      int getEnvironmentalMeasurementPluginUpdateInterval();

      /**
       * <pre>
       * Sometimes we can end up with more than read_error_count_threshold failures.
       * In this case, we will stop trying to read from the sensor for a while.
       * Wait this long until trying to read from the sensor again
       * </pre>
       *
       * <code>uint32 environmental_measurement_plugin_recovery_interval = 144;</code>
       * @return The environmentalMeasurementPluginRecoveryInterval.
       */
      int getEnvironmentalMeasurementPluginRecoveryInterval();

      /**
       * <pre>
       * We'll always read the sensor in Celsius, but sometimes we might want to
       * display the results in Farenheit as a "user preference".
       * </pre>
       *
       * <code>bool environmental_measurement_plugin_display_farenheit = 145;</code>
       * @return The environmentalMeasurementPluginDisplayFarenheit.
       */
      boolean getEnvironmentalMeasurementPluginDisplayFarenheit();

      /**
       * <pre>
       * Specify the sensor type
       * </pre>
       *
       * <code>.RadioConfig.UserPreferences.EnvironmentalMeasurementSensorType environmental_measurement_plugin_sensor_type = 146;</code>
       * @return The enum numeric value on the wire for environmentalMeasurementPluginSensorType.
       */
      int getEnvironmentalMeasurementPluginSensorTypeValue();
      /**
       * <pre>
       * Specify the sensor type
       * </pre>
       *
       * <code>.RadioConfig.UserPreferences.EnvironmentalMeasurementSensorType environmental_measurement_plugin_sensor_type = 146;</code>
       * @return The environmentalMeasurementPluginSensorType.
       */
      com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences.EnvironmentalMeasurementSensorType getEnvironmentalMeasurementPluginSensorType();

      /**
       * <pre>
       * Specify the peferred GPIO Pin for sensor readings
       * </pre>
       *
       * <code>uint32 environmental_measurement_plugin_sensor_pin = 147;</code>
       * @return The environmentalMeasurementPluginSensorPin.
       */
      int getEnvironmentalMeasurementPluginSensorPin();
    }
    /**
     * <pre>
     * see [software design](/software/other/sw-design.md) for more information on these preferences
     * </pre>
     *
     * Protobuf type {@code RadioConfig.UserPreferences}
     */
    public static final class UserPreferences extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:RadioConfig.UserPreferences)
        UserPreferencesOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use UserPreferences.newBuilder() to construct.
      private UserPreferences(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private UserPreferences() {
        wifiSsid_ = "";
        wifiPassword_ = "";
        region_ = 0;
        chargeCurrent_ = 0;
        locationShare_ = 0;
        gpsOperation_ = 0;
        mqttServer_ = "";
        ignoreIncoming_ = emptyIntList();
        environmentalMeasurementPluginSensorType_ = 0;
      }

      @java.lang.Override
      @SuppressWarnings({"unused"})
      protected java.lang.Object newInstance(
          UnusedPrivateParameter unused) {
        return new UserPreferences();
      }

      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      private UserPreferences(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        this();
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        int mutable_bitField0_ = 0;
        com.google.protobuf.UnknownFieldSet.Builder unknownFields =
            com.google.protobuf.UnknownFieldSet.newBuilder();
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {

                positionBroadcastSecs_ = input.readUInt32();
                break;
              }
              case 16: {

                sendOwnerInterval_ = input.readUInt32();
                break;
              }
              case 32: {

                waitBluetoothSecs_ = input.readUInt32();
                break;
              }
              case 40: {

                screenOnSecs_ = input.readUInt32();
                break;
              }
              case 48: {

                phoneTimeoutSecs_ = input.readUInt32();
                break;
              }
              case 56: {

                phoneSdsTimeoutSec_ = input.readUInt32();
                break;
              }
              case 64: {

                meshSdsTimeoutSecs_ = input.readUInt32();
                break;
              }
              case 72: {

                sdsSecs_ = input.readUInt32();
                break;
              }
              case 80: {

                lsSecs_ = input.readUInt32();
                break;
              }
              case 88: {

                minWakeSecs_ = input.readUInt32();
                break;
              }
              case 98: {
                java.lang.String s = input.readStringRequireUtf8();

                wifiSsid_ = s;
                break;
              }
              case 106: {
                java.lang.String s = input.readStringRequireUtf8();

                wifiPassword_ = s;
                break;
              }
              case 112: {

                wifiApMode_ = input.readBool();
                break;
              }
              case 120: {
                int rawValue = input.readEnum();

                region_ = rawValue;
                break;
              }
              case 128: {
                int rawValue = input.readEnum();

                chargeCurrent_ = rawValue;
                break;
              }
              case 256: {
                int rawValue = input.readEnum();

                locationShare_ = rawValue;
                break;
              }
              case 264: {
                int rawValue = input.readEnum();

                gpsOperation_ = rawValue;
                break;
              }
              case 272: {

                gpsUpdateInterval_ = input.readUInt32();
                break;
              }
              case 288: {

                gpsAttemptTime_ = input.readUInt32();
                break;
              }
              case 296: {

                isRouter_ = input.readBool();
                break;
              }
              case 304: {

                isLowPower_ = input.readBool();
                break;
              }
              case 312: {

                fixedPosition_ = input.readBool();
                break;
              }
              case 320: {

                serialDisabled_ = input.readBool();
                break;
              }
              case 333: {

                frequencyOffset_ = input.readFloat();
                break;
              }
              case 338: {
                java.lang.String s = input.readStringRequireUtf8();

                mqttServer_ = s;
                break;
              }
              case 344: {

                mqttDisabled_ = input.readBool();
                break;
              }
              case 800: {

                factoryReset_ = input.readBool();
                break;
              }
              case 808: {

                debugLogEnabled_ = input.readBool();
                break;
              }
              case 824: {
                if (!((mutable_bitField0_ & 0x00000001) != 0)) {
                  ignoreIncoming_ = newIntList();
                  mutable_bitField0_ |= 0x00000001;
                }
                ignoreIncoming_.addInt(input.readUInt32());
                break;
              }
              case 826: {
                int length = input.readRawVarint32();
                int limit = input.pushLimit(length);
                if (!((mutable_bitField0_ & 0x00000001) != 0) && input.getBytesUntilLimit() > 0) {
                  ignoreIncoming_ = newIntList();
                  mutable_bitField0_ |= 0x00000001;
                }
                while (input.getBytesUntilLimit() > 0) {
                  ignoreIncoming_.addInt(input.readUInt32());
                }
                input.popLimit(limit);
                break;
              }
              case 960: {

                serialpluginEnabled_ = input.readBool();
                break;
              }
              case 968: {

                serialpluginEcho_ = input.readBool();
                break;
              }
              case 976: {

                serialpluginRxd_ = input.readUInt32();
                break;
              }
              case 984: {

                serialpluginTxd_ = input.readUInt32();
                break;
              }
              case 992: {

                serialpluginTimeout_ = input.readUInt32();
                break;
              }
              case 1000: {

                serialpluginMode_ = input.readUInt32();
                break;
              }
              case 1008: {

                extNotificationPluginEnabled_ = input.readBool();
                break;
              }
              case 1016: {

                extNotificationPluginOutputMs_ = input.readUInt32();
                break;
              }
              case 1024: {

                extNotificationPluginOutput_ = input.readUInt32();
                break;
              }
              case 1032: {

                extNotificationPluginActive_ = input.readBool();
                break;
              }
              case 1040: {

                extNotificationPluginAlertMessage_ = input.readBool();
                break;
              }
              case 1048: {

                extNotificationPluginAlertBell_ = input.readBool();
                break;
              }
              case 1056: {

                rangeTestPluginEnabled_ = input.readBool();
                break;
              }
              case 1064: {

                rangeTestPluginSender_ = input.readUInt32();
                break;
              }
              case 1072: {

                rangeTestPluginSave_ = input.readBool();
                break;
              }
              case 1096: {

                storeForwardPluginRecords_ = input.readUInt32();
                break;
              }
              case 1120: {

                environmentalMeasurementPluginMeasurementEnabled_ = input.readBool();
                break;
              }
              case 1128: {

                environmentalMeasurementPluginScreenEnabled_ = input.readBool();
                break;
              }
              case 1136: {

                environmentalMeasurementPluginReadErrorCountThreshold_ = input.readUInt32();
                break;
              }
              case 1144: {

                environmentalMeasurementPluginUpdateInterval_ = input.readUInt32();
                break;
              }
              case 1152: {

                environmentalMeasurementPluginRecoveryInterval_ = input.readUInt32();
                break;
              }
              case 1160: {

                environmentalMeasurementPluginDisplayFarenheit_ = input.readBool();
                break;
              }
              case 1168: {
                int rawValue = input.readEnum();

                environmentalMeasurementPluginSensorType_ = rawValue;
                break;
              }
              case 1176: {

                environmentalMeasurementPluginSensorPin_ = input.readUInt32();
                break;
              }
              case 1184: {

                storeForwardPluginEnabled_ = input.readBool();
                break;
              }
              default: {
                if (!parseUnknownField(
                    input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
            }
          }
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(this);
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(
              e).setUnfinishedMessage(this);
        } finally {
          if (((mutable_bitField0_ & 0x00000001) != 0)) {
            ignoreIncoming_.makeImmutable(); // C
          }
          this.unknownFields = unknownFields.build();
          makeExtensionsImmutable();
        }
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.geeksville.mesh.RadioConfigProtos.internal_static_RadioConfig_UserPreferences_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.geeksville.mesh.RadioConfigProtos.internal_static_RadioConfig_UserPreferences_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences.class, com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences.Builder.class);
      }

      /**
       * Protobuf enum {@code RadioConfig.UserPreferences.EnvironmentalMeasurementSensorType}
       */
      public enum EnvironmentalMeasurementSensorType
          implements com.google.protobuf.ProtocolMessageEnum {
        /**
         * <code>DHT11 = 0;</code>
         */
        DHT11(0),
        UNRECOGNIZED(-1),
        ;

        /**
         * <code>DHT11 = 0;</code>
         */
        public static final int DHT11_VALUE = 0;


        public final int getNumber() {
          if (this == UNRECOGNIZED) {
            throw new java.lang.IllegalArgumentException(
                "Can't get the number of an unknown enum value.");
          }
          return value;
        }

        /**
         * @param value The numeric wire value of the corresponding enum entry.
         * @return The enum associated with the given numeric wire value.
         * @deprecated Use {@link #forNumber(int)} instead.
         */
        @java.lang.Deprecated
        public static EnvironmentalMeasurementSensorType valueOf(int value) {
          return forNumber(value);
        }

        /**
         * @param value The numeric wire value of the corresponding enum entry.
         * @return The enum associated with the given numeric wire value.
         */
        public static EnvironmentalMeasurementSensorType forNumber(int value) {
          switch (value) {
            case 0: return DHT11;
            default: return null;
          }
        }

        public static com.google.protobuf.Internal.EnumLiteMap<EnvironmentalMeasurementSensorType>
            internalGetValueMap() {
          return internalValueMap;
        }
        private static final com.google.protobuf.Internal.EnumLiteMap<
            EnvironmentalMeasurementSensorType> internalValueMap =
              new com.google.protobuf.Internal.EnumLiteMap<EnvironmentalMeasurementSensorType>() {
                public EnvironmentalMeasurementSensorType findValueByNumber(int number) {
                  return EnvironmentalMeasurementSensorType.forNumber(number);
                }
              };

        public final com.google.protobuf.Descriptors.EnumValueDescriptor
            getValueDescriptor() {
          if (this == UNRECOGNIZED) {
            throw new java.lang.IllegalStateException(
                "Can't get the descriptor of an unrecognized enum value.");
          }
          return getDescriptor().getValues().get(ordinal());
        }
        public final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptorForType() {
          return getDescriptor();
        }
        public static final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptor() {
          return com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences.getDescriptor().getEnumTypes().get(0);
        }

        private static final EnvironmentalMeasurementSensorType[] VALUES = values();

        public static EnvironmentalMeasurementSensorType valueOf(
            com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
          if (desc.getType() != getDescriptor()) {
            throw new java.lang.IllegalArgumentException(
              "EnumValueDescriptor is not for this type.");
          }
          if (desc.getIndex() == -1) {
            return UNRECOGNIZED;
          }
          return VALUES[desc.getIndex()];
        }

        private final int value;

        private EnvironmentalMeasurementSensorType(int value) {
          this.value = value;
        }

        // @@protoc_insertion_point(enum_scope:RadioConfig.UserPreferences.EnvironmentalMeasurementSensorType)
      }

      public static final int POSITION_BROADCAST_SECS_FIELD_NUMBER = 1;
      private int positionBroadcastSecs_;
      /**
       * <pre>
       * We should send our position this often (but only if it has changed significantly)
       * Defaults to 15 minutes
       * </pre>
       *
       * <code>uint32 position_broadcast_secs = 1;</code>
       * @return The positionBroadcastSecs.
       */
      @java.lang.Override
      public int getPositionBroadcastSecs() {
        return positionBroadcastSecs_;
      }

      public static final int SEND_OWNER_INTERVAL_FIELD_NUMBER = 2;
      private int sendOwnerInterval_;
      /**
       * <pre>
       * Send our owner info at least this often (also we always send once at boot - to rejoin the mesh)
       * </pre>
       *
       * <code>uint32 send_owner_interval = 2;</code>
       * @return The sendOwnerInterval.
       */
      @java.lang.Override
      public int getSendOwnerInterval() {
        return sendOwnerInterval_;
      }

      public static final int WAIT_BLUETOOTH_SECS_FIELD_NUMBER = 4;
      private int waitBluetoothSecs_;
      /**
       * <pre>
       * Power management state machine option.
       * See [power management](/software/other/power.md) for details.
       * 0 for default of 1 minute
       * </pre>
       *
       * <code>uint32 wait_bluetooth_secs = 4;</code>
       * @return The waitBluetoothSecs.
       */
      @java.lang.Override
      public int getWaitBluetoothSecs() {
        return waitBluetoothSecs_;
      }

      public static final int SCREEN_ON_SECS_FIELD_NUMBER = 5;
      private int screenOnSecs_;
      /**
       * <pre>
       * Power management state machine option.
       * See [power management](/software/other/power.md) for details.
       * 0 for default of one minute
       * </pre>
       *
       * <code>uint32 screen_on_secs = 5;</code>
       * @return The screenOnSecs.
       */
      @java.lang.Override
      public int getScreenOnSecs() {
        return screenOnSecs_;
      }

      public static final int PHONE_TIMEOUT_SECS_FIELD_NUMBER = 6;
      private int phoneTimeoutSecs_;
      /**
       * <pre>
       * Power management state machine option.
       * See [power management](/software/other/power.md) for details.
       * 0 for default of 15 minutes
       * IMPORTANT NOTE FOR DEVICE CLIENTS: YOU MUST SEND SOME SORT OF PACKET TO THE PHONE AT LEAST THIS OFTEN OR THE DEVICE WILL DECIDE YOU ARE GONE!
       * </pre>
       *
       * <code>uint32 phone_timeout_secs = 6;</code>
       * @return The phoneTimeoutSecs.
       */
      @java.lang.Override
      public int getPhoneTimeoutSecs() {
        return phoneTimeoutSecs_;
      }

      public static final int PHONE_SDS_TIMEOUT_SEC_FIELD_NUMBER = 7;
      private int phoneSdsTimeoutSec_;
      /**
       * <pre>
       * Power management state machine option.
       * See [power management](/software/other/power.md) for details.
       * 0 for default of two hours, MAXUINT for disabled
       * </pre>
       *
       * <code>uint32 phone_sds_timeout_sec = 7;</code>
       * @return The phoneSdsTimeoutSec.
       */
      @java.lang.Override
      public int getPhoneSdsTimeoutSec() {
        return phoneSdsTimeoutSec_;
      }

      public static final int MESH_SDS_TIMEOUT_SECS_FIELD_NUMBER = 8;
      private int meshSdsTimeoutSecs_;
      /**
       * <pre>
       * Power management state machine option.
       * See [power management](/software/other/power.md) for details.
       * 0 for default of two hours, MAXUINT for disabled
       * </pre>
       *
       * <code>uint32 mesh_sds_timeout_secs = 8;</code>
       * @return The meshSdsTimeoutSecs.
       */
      @java.lang.Override
      public int getMeshSdsTimeoutSecs() {
        return meshSdsTimeoutSecs_;
      }

      public static final int SDS_SECS_FIELD_NUMBER = 9;
      private int sdsSecs_;
      /**
       * <pre>
       * Power management state machine option.
       * See [power management](/software/other/power.md) for details.
       * 0 for default of one year
       * </pre>
       *
       * <code>uint32 sds_secs = 9;</code>
       * @return The sdsSecs.
       */
      @java.lang.Override
      public int getSdsSecs() {
        return sdsSecs_;
      }

      public static final int LS_SECS_FIELD_NUMBER = 10;
      private int lsSecs_;
      /**
       * <pre>
       * Power management state machine option.
       * See [power management](/software/other/power.md) for details.
       * 0 for default of 3600
       * </pre>
       *
       * <code>uint32 ls_secs = 10;</code>
       * @return The lsSecs.
       */
      @java.lang.Override
      public int getLsSecs() {
        return lsSecs_;
      }

      public static final int MIN_WAKE_SECS_FIELD_NUMBER = 11;
      private int minWakeSecs_;
      /**
       * <pre>
       * Power management state machine option.
       * See [power management](/software/other/power.md) for details.
       * 0 for default of 10 seconds
       * </pre>
       *
       * <code>uint32 min_wake_secs = 11;</code>
       * @return The minWakeSecs.
       */
      @java.lang.Override
      public int getMinWakeSecs() {
        return minWakeSecs_;
      }

      public static final int WIFI_SSID_FIELD_NUMBER = 12;
      private volatile java.lang.Object wifiSsid_;
      /**
       * <pre>
       * If set, this node will try to join the specified wifi network and
       * acquire an address via DHCP
       * </pre>
       *
       * <code>string wifi_ssid = 12;</code>
       * @return The wifiSsid.
       */
      @java.lang.Override
      public java.lang.String getWifiSsid() {
        java.lang.Object ref = wifiSsid_;
        if (ref instanceof java.lang.String) {
          return (java.lang.String) ref;
        } else {
          com.google.protobuf.ByteString bs = 
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          wifiSsid_ = s;
          return s;
        }
      }
      /**
       * <pre>
       * If set, this node will try to join the specified wifi network and
       * acquire an address via DHCP
       * </pre>
       *
       * <code>string wifi_ssid = 12;</code>
       * @return The bytes for wifiSsid.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getWifiSsidBytes() {
        java.lang.Object ref = wifiSsid_;
        if (ref instanceof java.lang.String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          wifiSsid_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      public static final int WIFI_PASSWORD_FIELD_NUMBER = 13;
      private volatile java.lang.Object wifiPassword_;
      /**
       * <pre>
       * If set, will be use to authenticate to the named wifi
       * </pre>
       *
       * <code>string wifi_password = 13;</code>
       * @return The wifiPassword.
       */
      @java.lang.Override
      public java.lang.String getWifiPassword() {
        java.lang.Object ref = wifiPassword_;
        if (ref instanceof java.lang.String) {
          return (java.lang.String) ref;
        } else {
          com.google.protobuf.ByteString bs = 
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          wifiPassword_ = s;
          return s;
        }
      }
      /**
       * <pre>
       * If set, will be use to authenticate to the named wifi
       * </pre>
       *
       * <code>string wifi_password = 13;</code>
       * @return The bytes for wifiPassword.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getWifiPasswordBytes() {
        java.lang.Object ref = wifiPassword_;
        if (ref instanceof java.lang.String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          wifiPassword_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      public static final int WIFI_AP_MODE_FIELD_NUMBER = 14;
      private boolean wifiApMode_;
      /**
       * <pre>
       * If set, the node will operate as an AP (and DHCP server), otherwise it
       * will be a station
       * </pre>
       *
       * <code>bool wifi_ap_mode = 14;</code>
       * @return The wifiApMode.
       */
      @java.lang.Override
      public boolean getWifiApMode() {
        return wifiApMode_;
      }

      public static final int REGION_FIELD_NUMBER = 15;
      private int region_;
      /**
       * <pre>
       * The region code for my radio (US, CN, EU433, etc...)
       * </pre>
       *
       * <code>.RegionCode region = 15;</code>
       * @return The enum numeric value on the wire for region.
       */
      @java.lang.Override public int getRegionValue() {
        return region_;
      }
      /**
       * <pre>
       * The region code for my radio (US, CN, EU433, etc...)
       * </pre>
       *
       * <code>.RegionCode region = 15;</code>
       * @return The region.
       */
      @java.lang.Override public com.geeksville.mesh.RadioConfigProtos.RegionCode getRegion() {
        @SuppressWarnings("deprecation")
        com.geeksville.mesh.RadioConfigProtos.RegionCode result = com.geeksville.mesh.RadioConfigProtos.RegionCode.valueOf(region_);
        return result == null ? com.geeksville.mesh.RadioConfigProtos.RegionCode.UNRECOGNIZED : result;
      }

      public static final int CHARGE_CURRENT_FIELD_NUMBER = 16;
      private int chargeCurrent_;
      /**
       * <pre>
       * Sets the current of the battery charger
       * </pre>
       *
       * <code>.ChargeCurrent charge_current = 16;</code>
       * @return The enum numeric value on the wire for chargeCurrent.
       */
      @java.lang.Override public int getChargeCurrentValue() {
        return chargeCurrent_;
      }
      /**
       * <pre>
       * Sets the current of the battery charger
       * </pre>
       *
       * <code>.ChargeCurrent charge_current = 16;</code>
       * @return The chargeCurrent.
       */
      @java.lang.Override public com.geeksville.mesh.RadioConfigProtos.ChargeCurrent getChargeCurrent() {
        @SuppressWarnings("deprecation")
        com.geeksville.mesh.RadioConfigProtos.ChargeCurrent result = com.geeksville.mesh.RadioConfigProtos.ChargeCurrent.valueOf(chargeCurrent_);
        return result == null ? com.geeksville.mesh.RadioConfigProtos.ChargeCurrent.UNRECOGNIZED : result;
      }

      public static final int IS_ROUTER_FIELD_NUMBER = 37;
      private boolean isRouter_;
      /**
       * <pre>
       * Are we operating as a router.
       * Changes behavior in the following ways:
       * The device will only sleep for critically low battery level (i.e. always tries to stay alive for the mesh)
       * In the future routing decisions will preferentially route packets through nodes with this attribute (because assumed
       * good line of sight)
       * </pre>
       *
       * <code>bool is_router = 37;</code>
       * @return The isRouter.
       */
      @java.lang.Override
      public boolean getIsRouter() {
        return isRouter_;
      }

      public static final int IS_LOW_POWER_FIELD_NUMBER = 38;
      private boolean isLowPower_;
      /**
       * <pre>
       * If set, we are powered from a low-current source (i.e. solar), so even if it looks like we have power flowing in
       * we should try to minimize power consumption as much as possible.
       * YOU DO NOT NEED TO SET THIS IF YOU'VE set is_router (it is implied in that case).
       * </pre>
       *
       * <code>bool is_low_power = 38;</code>
       * @return The isLowPower.
       */
      @java.lang.Override
      public boolean getIsLowPower() {
        return isLowPower_;
      }

      public static final int FIXED_POSITION_FIELD_NUMBER = 39;
      private boolean fixedPosition_;
      /**
       * <pre>
       * If set, this node is at a fixed position.
       * We will generate GPS position updates at the regular interval, but use whatever the last lat/lon/alt we have for the node.
       * The lat/lon/alt can be set by an internal GPS or with the help of the app.
       * </pre>
       *
       * <code>bool fixed_position = 39;</code>
       * @return The fixedPosition.
       */
      @java.lang.Override
      public boolean getFixedPosition() {
        return fixedPosition_;
      }

      public static final int SERIAL_DISABLED_FIELD_NUMBER = 40;
      private boolean serialDisabled_;
      /**
       * <pre>
       * If set, this will disable the SerialConsole by not initilizing the StreamAPI
       * </pre>
       *
       * <code>bool serial_disabled = 40;</code>
       * @return The serialDisabled.
       */
      @java.lang.Override
      public boolean getSerialDisabled() {
        return serialDisabled_;
      }

      public static final int LOCATION_SHARE_FIELD_NUMBER = 32;
      private int locationShare_;
      /**
       * <pre>
       * How our location is shared with other nodes (or the local phone)
       * </pre>
       *
       * <code>.LocationSharing location_share = 32;</code>
       * @return The enum numeric value on the wire for locationShare.
       */
      @java.lang.Override public int getLocationShareValue() {
        return locationShare_;
      }
      /**
       * <pre>
       * How our location is shared with other nodes (or the local phone)
       * </pre>
       *
       * <code>.LocationSharing location_share = 32;</code>
       * @return The locationShare.
       */
      @java.lang.Override public com.geeksville.mesh.RadioConfigProtos.LocationSharing getLocationShare() {
        @SuppressWarnings("deprecation")
        com.geeksville.mesh.RadioConfigProtos.LocationSharing result = com.geeksville.mesh.RadioConfigProtos.LocationSharing.valueOf(locationShare_);
        return result == null ? com.geeksville.mesh.RadioConfigProtos.LocationSharing.UNRECOGNIZED : result;
      }

      public static final int GPS_OPERATION_FIELD_NUMBER = 33;
      private int gpsOperation_;
      /**
       * <pre>
       * How the GPS hardware in this unit is operated.
       * Note: This is independent of how our location is shared with other devices.
       * For that see LocationSharing
       * </pre>
       *
       * <code>.GpsOperation gps_operation = 33;</code>
       * @return The enum numeric value on the wire for gpsOperation.
       */
      @java.lang.Override public int getGpsOperationValue() {
        return gpsOperation_;
      }
      /**
       * <pre>
       * How the GPS hardware in this unit is operated.
       * Note: This is independent of how our location is shared with other devices.
       * For that see LocationSharing
       * </pre>
       *
       * <code>.GpsOperation gps_operation = 33;</code>
       * @return The gpsOperation.
       */
      @java.lang.Override public com.geeksville.mesh.RadioConfigProtos.GpsOperation getGpsOperation() {
        @SuppressWarnings("deprecation")
        com.geeksville.mesh.RadioConfigProtos.GpsOperation result = com.geeksville.mesh.RadioConfigProtos.GpsOperation.valueOf(gpsOperation_);
        return result == null ? com.geeksville.mesh.RadioConfigProtos.GpsOperation.UNRECOGNIZED : result;
      }

      public static final int GPS_UPDATE_INTERVAL_FIELD_NUMBER = 34;
      private int gpsUpdateInterval_;
      /**
       * <pre>
       * How often should we try to get GPS position (in seconds) when we are in GpsOpMobile mode?
       * or zero for the default of once every 30 seconds
       * or a very large value (maxint) to update only once at boot.
       * </pre>
       *
       * <code>uint32 gps_update_interval = 34;</code>
       * @return The gpsUpdateInterval.
       */
      @java.lang.Override
      public int getGpsUpdateInterval() {
        return gpsUpdateInterval_;
      }

      public static final int GPS_ATTEMPT_TIME_FIELD_NUMBER = 36;
      private int gpsAttemptTime_;
      /**
       * <pre>
       * How long should we try to get our position during each gps_update_interval attempt?  (in seconds)
       * Or if zero, use the default of 30 seconds.
       * If we don't get a new gps fix in that time, the gps will be put into sleep until  the next gps_update_rate
       * window. 
       * </pre>
       *
       * <code>uint32 gps_attempt_time = 36;</code>
       * @return The gpsAttemptTime.
       */
      @java.lang.Override
      public int getGpsAttemptTime() {
        return gpsAttemptTime_;
      }

      public static final int FREQUENCY_OFFSET_FIELD_NUMBER = 41;
      private float frequencyOffset_;
      /**
       * <pre>
       * This parameter is for advanced users with advanced test equipment, we do not recommend most users use it.
       * A frequency offset that is added to to the calculated band center frequency.
       * Used to correct for crystal calibration errors.
       * </pre>
       *
       * <code>float frequency_offset = 41;</code>
       * @return The frequencyOffset.
       */
      @java.lang.Override
      public float getFrequencyOffset() {
        return frequencyOffset_;
      }

      public static final int MQTT_SERVER_FIELD_NUMBER = 42;
      private volatile java.lang.Object mqttServer_;
      /**
       * <pre>
       * The server to use for our MQTT global message gateway feature.
       * If not set, the default server will be used 
       * </pre>
       *
       * <code>string mqtt_server = 42;</code>
       * @return The mqttServer.
       */
      @java.lang.Override
      public java.lang.String getMqttServer() {
        java.lang.Object ref = mqttServer_;
        if (ref instanceof java.lang.String) {
          return (java.lang.String) ref;
        } else {
          com.google.protobuf.ByteString bs = 
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          mqttServer_ = s;
          return s;
        }
      }
      /**
       * <pre>
       * The server to use for our MQTT global message gateway feature.
       * If not set, the default server will be used 
       * </pre>
       *
       * <code>string mqtt_server = 42;</code>
       * @return The bytes for mqttServer.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getMqttServerBytes() {
        java.lang.Object ref = mqttServer_;
        if (ref instanceof java.lang.String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          mqttServer_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      public static final int MQTT_DISABLED_FIELD_NUMBER = 43;
      private boolean mqttDisabled_;
      /**
       * <pre>
       * If a meshtastic node is able to reach the internet it will normally attempt to gateway any channels that are marked as
       * is_uplink_enabled or is_downlink_enabled.
       * But if this flag is set, all MQTT features will be disabled and no servers will be contacted.
       * </pre>
       *
       * <code>bool mqtt_disabled = 43;</code>
       * @return The mqttDisabled.
       */
      @java.lang.Override
      public boolean getMqttDisabled() {
        return mqttDisabled_;
      }

      public static final int FACTORY_RESET_FIELD_NUMBER = 100;
      private boolean factoryReset_;
      /**
       * <pre>
       * This setting is never saved to disk, but if set, all device settings will be returned to factory defaults.
       * (Region, serial number etc... will be preserved)
       * </pre>
       *
       * <code>bool factory_reset = 100;</code>
       * @return The factoryReset.
       */
      @java.lang.Override
      public boolean getFactoryReset() {
        return factoryReset_;
      }

      public static final int DEBUG_LOG_ENABLED_FIELD_NUMBER = 101;
      private boolean debugLogEnabled_;
      /**
       * <pre>
       * By default we turn off logging as soon as an API client connects (to keep shared serial link quiet).
       * Set this to true to leave the debug log outputting even when API is active.
       * </pre>
       *
       * <code>bool debug_log_enabled = 101;</code>
       * @return The debugLogEnabled.
       */
      @java.lang.Override
      public boolean getDebugLogEnabled() {
        return debugLogEnabled_;
      }

      public static final int IGNORE_INCOMING_FIELD_NUMBER = 103;
      private com.google.protobuf.Internal.IntList ignoreIncoming_;
      /**
       * <pre>
       * If true, radio should not try to be smart about what packets to queue to
       * the phone
       * bool keep_all_packets = 101;
       * If true, we will try to capture all the packets sent on the mesh, not just the ones destined to our node.
       * bool promiscuous_mode = 102;
       * For testing it is useful sometimes to force a node to never listen to
       * particular other nodes (simulating radio out of range). All nodenums listed
       * in ignore_incoming will have packets they send droped on receive (by router.cpp)
       * </pre>
       *
       * <code>repeated uint32 ignore_incoming = 103;</code>
       * @return A list containing the ignoreIncoming.
       */
      @java.lang.Override
      public java.util.List<java.lang.Integer>
          getIgnoreIncomingList() {
        return ignoreIncoming_;
      }
      /**
       * <pre>
       * If true, radio should not try to be smart about what packets to queue to
       * the phone
       * bool keep_all_packets = 101;
       * If true, we will try to capture all the packets sent on the mesh, not just the ones destined to our node.
       * bool promiscuous_mode = 102;
       * For testing it is useful sometimes to force a node to never listen to
       * particular other nodes (simulating radio out of range). All nodenums listed
       * in ignore_incoming will have packets they send droped on receive (by router.cpp)
       * </pre>
       *
       * <code>repeated uint32 ignore_incoming = 103;</code>
       * @return The count of ignoreIncoming.
       */
      public int getIgnoreIncomingCount() {
        return ignoreIncoming_.size();
      }
      /**
       * <pre>
       * If true, radio should not try to be smart about what packets to queue to
       * the phone
       * bool keep_all_packets = 101;
       * If true, we will try to capture all the packets sent on the mesh, not just the ones destined to our node.
       * bool promiscuous_mode = 102;
       * For testing it is useful sometimes to force a node to never listen to
       * particular other nodes (simulating radio out of range). All nodenums listed
       * in ignore_incoming will have packets they send droped on receive (by router.cpp)
       * </pre>
       *
       * <code>repeated uint32 ignore_incoming = 103;</code>
       * @param index The index of the element to return.
       * @return The ignoreIncoming at the given index.
       */
      public int getIgnoreIncoming(int index) {
        return ignoreIncoming_.getInt(index);
      }
      private int ignoreIncomingMemoizedSerializedSize = -1;

      public static final int SERIALPLUGIN_ENABLED_FIELD_NUMBER = 120;
      private boolean serialpluginEnabled_;
      /**
       * <pre>
       * Preferences for the SerialPlugin
       * FIXME - Move this out of UserPreferences and into a section for plugin configuration.
       * </pre>
       *
       * <code>bool serialplugin_enabled = 120;</code>
       * @return The serialpluginEnabled.
       */
      @java.lang.Override
      public boolean getSerialpluginEnabled() {
        return serialpluginEnabled_;
      }

      public static final int SERIALPLUGIN_ECHO_FIELD_NUMBER = 121;
      private boolean serialpluginEcho_;
      /**
       * <code>bool serialplugin_echo = 121;</code>
       * @return The serialpluginEcho.
       */
      @java.lang.Override
      public boolean getSerialpluginEcho() {
        return serialpluginEcho_;
      }

      public static final int SERIALPLUGIN_RXD_FIELD_NUMBER = 122;
      private int serialpluginRxd_;
      /**
       * <code>uint32 serialplugin_rxd = 122;</code>
       * @return The serialpluginRxd.
       */
      @java.lang.Override
      public int getSerialpluginRxd() {
        return serialpluginRxd_;
      }

      public static final int SERIALPLUGIN_TXD_FIELD_NUMBER = 123;
      private int serialpluginTxd_;
      /**
       * <code>uint32 serialplugin_txd = 123;</code>
       * @return The serialpluginTxd.
       */
      @java.lang.Override
      public int getSerialpluginTxd() {
        return serialpluginTxd_;
      }

      public static final int SERIALPLUGIN_TIMEOUT_FIELD_NUMBER = 124;
      private int serialpluginTimeout_;
      /**
       * <code>uint32 serialplugin_timeout = 124;</code>
       * @return The serialpluginTimeout.
       */
      @java.lang.Override
      public int getSerialpluginTimeout() {
        return serialpluginTimeout_;
      }

      public static final int SERIALPLUGIN_MODE_FIELD_NUMBER = 125;
      private int serialpluginMode_;
      /**
       * <code>uint32 serialplugin_mode = 125;</code>
       * @return The serialpluginMode.
       */
      @java.lang.Override
      public int getSerialpluginMode() {
        return serialpluginMode_;
      }

      public static final int EXT_NOTIFICATION_PLUGIN_ENABLED_FIELD_NUMBER = 126;
      private boolean extNotificationPluginEnabled_;
      /**
       * <pre>
       * Preferences for the ExternalNotificationPlugin
       * FIXME - Move this out of UserPreferences and into a section for plugin configuration.
       * </pre>
       *
       * <code>bool ext_notification_plugin_enabled = 126;</code>
       * @return The extNotificationPluginEnabled.
       */
      @java.lang.Override
      public boolean getExtNotificationPluginEnabled() {
        return extNotificationPluginEnabled_;
      }

      public static final int EXT_NOTIFICATION_PLUGIN_OUTPUT_MS_FIELD_NUMBER = 127;
      private int extNotificationPluginOutputMs_;
      /**
       * <code>uint32 ext_notification_plugin_output_ms = 127;</code>
       * @return The extNotificationPluginOutputMs.
       */
      @java.lang.Override
      public int getExtNotificationPluginOutputMs() {
        return extNotificationPluginOutputMs_;
      }

      public static final int EXT_NOTIFICATION_PLUGIN_OUTPUT_FIELD_NUMBER = 128;
      private int extNotificationPluginOutput_;
      /**
       * <code>uint32 ext_notification_plugin_output = 128;</code>
       * @return The extNotificationPluginOutput.
       */
      @java.lang.Override
      public int getExtNotificationPluginOutput() {
        return extNotificationPluginOutput_;
      }

      public static final int EXT_NOTIFICATION_PLUGIN_ACTIVE_FIELD_NUMBER = 129;
      private boolean extNotificationPluginActive_;
      /**
       * <code>bool ext_notification_plugin_active = 129;</code>
       * @return The extNotificationPluginActive.
       */
      @java.lang.Override
      public boolean getExtNotificationPluginActive() {
        return extNotificationPluginActive_;
      }

      public static final int EXT_NOTIFICATION_PLUGIN_ALERT_MESSAGE_FIELD_NUMBER = 130;
      private boolean extNotificationPluginAlertMessage_;
      /**
       * <code>bool ext_notification_plugin_alert_message = 130;</code>
       * @return The extNotificationPluginAlertMessage.
       */
      @java.lang.Override
      public boolean getExtNotificationPluginAlertMessage() {
        return extNotificationPluginAlertMessage_;
      }

      public static final int EXT_NOTIFICATION_PLUGIN_ALERT_BELL_FIELD_NUMBER = 131;
      private boolean extNotificationPluginAlertBell_;
      /**
       * <code>bool ext_notification_plugin_alert_bell = 131;</code>
       * @return The extNotificationPluginAlertBell.
       */
      @java.lang.Override
      public boolean getExtNotificationPluginAlertBell() {
        return extNotificationPluginAlertBell_;
      }

      public static final int RANGE_TEST_PLUGIN_ENABLED_FIELD_NUMBER = 132;
      private boolean rangeTestPluginEnabled_;
      /**
       * <pre>
       *Preferences for the RangeTestPlugin
       * FIXME - Move this out of UserPreferences and into a section for plugin configuration.
       * </pre>
       *
       * <code>bool range_test_plugin_enabled = 132;</code>
       * @return The rangeTestPluginEnabled.
       */
      @java.lang.Override
      public boolean getRangeTestPluginEnabled() {
        return rangeTestPluginEnabled_;
      }

      public static final int RANGE_TEST_PLUGIN_SENDER_FIELD_NUMBER = 133;
      private int rangeTestPluginSender_;
      /**
       * <code>uint32 range_test_plugin_sender = 133;</code>
       * @return The rangeTestPluginSender.
       */
      @java.lang.Override
      public int getRangeTestPluginSender() {
        return rangeTestPluginSender_;
      }

      public static final int RANGE_TEST_PLUGIN_SAVE_FIELD_NUMBER = 134;
      private boolean rangeTestPluginSave_;
      /**
       * <code>bool range_test_plugin_save = 134;</code>
       * @return The rangeTestPluginSave.
       */
      @java.lang.Override
      public boolean getRangeTestPluginSave() {
        return rangeTestPluginSave_;
      }

      public static final int STORE_FORWARD_PLUGIN_ENABLED_FIELD_NUMBER = 148;
      private boolean storeForwardPluginEnabled_;
      /**
       * <pre>
       * Preferences for the StoreForwardPlugin
       *FIXME - Move this out of UserPreferences and into a section for plugin configuration. (was 136)
       * </pre>
       *
       * <code>bool store_forward_plugin_enabled = 148;</code>
       * @return The storeForwardPluginEnabled.
       */
      @java.lang.Override
      public boolean getStoreForwardPluginEnabled() {
        return storeForwardPluginEnabled_;
      }

      public static final int STORE_FORWARD_PLUGIN_RECORDS_FIELD_NUMBER = 137;
      private int storeForwardPluginRecords_;
      /**
       * <code>uint32 store_forward_plugin_records = 137;</code>
       * @return The storeForwardPluginRecords.
       */
      @java.lang.Override
      public int getStoreForwardPluginRecords() {
        return storeForwardPluginRecords_;
      }

      public static final int ENVIRONMENTAL_MEASUREMENT_PLUGIN_MEASUREMENT_ENABLED_FIELD_NUMBER = 140;
      private boolean environmentalMeasurementPluginMeasurementEnabled_;
      /**
       * <pre>
       * Preferences for the EnvironmentalMeasurement Plugin
       * FIXME - Move this out of UserPreferences and into a section for plugin configuration.
       * Enable/Disable the environmental measurement plugin measurement collection
       * </pre>
       *
       * <code>bool environmental_measurement_plugin_measurement_enabled = 140;</code>
       * @return The environmentalMeasurementPluginMeasurementEnabled.
       */
      @java.lang.Override
      public boolean getEnvironmentalMeasurementPluginMeasurementEnabled() {
        return environmentalMeasurementPluginMeasurementEnabled_;
      }

      public static final int ENVIRONMENTAL_MEASUREMENT_PLUGIN_SCREEN_ENABLED_FIELD_NUMBER = 141;
      private boolean environmentalMeasurementPluginScreenEnabled_;
      /**
       * <pre>
       * Enable/Disable the environmental measurement plugin on-device display
       * </pre>
       *
       * <code>bool environmental_measurement_plugin_screen_enabled = 141;</code>
       * @return The environmentalMeasurementPluginScreenEnabled.
       */
      @java.lang.Override
      public boolean getEnvironmentalMeasurementPluginScreenEnabled() {
        return environmentalMeasurementPluginScreenEnabled_;
      }

      public static final int ENVIRONMENTAL_MEASUREMENT_PLUGIN_READ_ERROR_COUNT_THRESHOLD_FIELD_NUMBER = 142;
      private int environmentalMeasurementPluginReadErrorCountThreshold_;
      /**
       * <pre>
       * Sometimes sensor reads can fail.
       * If this happens, we will retry a configurable number of attempts,
       * each attempt will be delayed by the minimum required refresh rate for that sensor
       * </pre>
       *
       * <code>uint32 environmental_measurement_plugin_read_error_count_threshold = 142;</code>
       * @return The environmentalMeasurementPluginReadErrorCountThreshold.
       */
      @java.lang.Override
      public int getEnvironmentalMeasurementPluginReadErrorCountThreshold() {
        return environmentalMeasurementPluginReadErrorCountThreshold_;
      }

      public static final int ENVIRONMENTAL_MEASUREMENT_PLUGIN_UPDATE_INTERVAL_FIELD_NUMBER = 143;
      private int environmentalMeasurementPluginUpdateInterval_;
      /**
       * <pre>
       * Interval in seconds of how often we should try to send our 
       * measurements to the mesh
       * </pre>
       *
       * <code>uint32 environmental_measurement_plugin_update_interval = 143;</code>
       * @return The environmentalMeasurementPluginUpdateInterval.
       */
      @java.lang.Override
      public int getEnvironmentalMeasurementPluginUpdateInterval() {
        return environmentalMeasurementPluginUpdateInterval_;
      }

      public static final int ENVIRONMENTAL_MEASUREMENT_PLUGIN_RECOVERY_INTERVAL_FIELD_NUMBER = 144;
      private int environmentalMeasurementPluginRecoveryInterval_;
      /**
       * <pre>
       * Sometimes we can end up with more than read_error_count_threshold failures.
       * In this case, we will stop trying to read from the sensor for a while.
       * Wait this long until trying to read from the sensor again
       * </pre>
       *
       * <code>uint32 environmental_measurement_plugin_recovery_interval = 144;</code>
       * @return The environmentalMeasurementPluginRecoveryInterval.
       */
      @java.lang.Override
      public int getEnvironmentalMeasurementPluginRecoveryInterval() {
        return environmentalMeasurementPluginRecoveryInterval_;
      }

      public static final int ENVIRONMENTAL_MEASUREMENT_PLUGIN_DISPLAY_FARENHEIT_FIELD_NUMBER = 145;
      private boolean environmentalMeasurementPluginDisplayFarenheit_;
      /**
       * <pre>
       * We'll always read the sensor in Celsius, but sometimes we might want to
       * display the results in Farenheit as a "user preference".
       * </pre>
       *
       * <code>bool environmental_measurement_plugin_display_farenheit = 145;</code>
       * @return The environmentalMeasurementPluginDisplayFarenheit.
       */
      @java.lang.Override
      public boolean getEnvironmentalMeasurementPluginDisplayFarenheit() {
        return environmentalMeasurementPluginDisplayFarenheit_;
      }

      public static final int ENVIRONMENTAL_MEASUREMENT_PLUGIN_SENSOR_TYPE_FIELD_NUMBER = 146;
      private int environmentalMeasurementPluginSensorType_;
      /**
       * <pre>
       * Specify the sensor type
       * </pre>
       *
       * <code>.RadioConfig.UserPreferences.EnvironmentalMeasurementSensorType environmental_measurement_plugin_sensor_type = 146;</code>
       * @return The enum numeric value on the wire for environmentalMeasurementPluginSensorType.
       */
      @java.lang.Override public int getEnvironmentalMeasurementPluginSensorTypeValue() {
        return environmentalMeasurementPluginSensorType_;
      }
      /**
       * <pre>
       * Specify the sensor type
       * </pre>
       *
       * <code>.RadioConfig.UserPreferences.EnvironmentalMeasurementSensorType environmental_measurement_plugin_sensor_type = 146;</code>
       * @return The environmentalMeasurementPluginSensorType.
       */
      @java.lang.Override public com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences.EnvironmentalMeasurementSensorType getEnvironmentalMeasurementPluginSensorType() {
        @SuppressWarnings("deprecation")
        com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences.EnvironmentalMeasurementSensorType result = com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences.EnvironmentalMeasurementSensorType.valueOf(environmentalMeasurementPluginSensorType_);
        return result == null ? com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences.EnvironmentalMeasurementSensorType.UNRECOGNIZED : result;
      }

      public static final int ENVIRONMENTAL_MEASUREMENT_PLUGIN_SENSOR_PIN_FIELD_NUMBER = 147;
      private int environmentalMeasurementPluginSensorPin_;
      /**
       * <pre>
       * Specify the peferred GPIO Pin for sensor readings
       * </pre>
       *
       * <code>uint32 environmental_measurement_plugin_sensor_pin = 147;</code>
       * @return The environmentalMeasurementPluginSensorPin.
       */
      @java.lang.Override
      public int getEnvironmentalMeasurementPluginSensorPin() {
        return environmentalMeasurementPluginSensorPin_;
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        getSerializedSize();
        if (positionBroadcastSecs_ != 0) {
          output.writeUInt32(1, positionBroadcastSecs_);
        }
        if (sendOwnerInterval_ != 0) {
          output.writeUInt32(2, sendOwnerInterval_);
        }
        if (waitBluetoothSecs_ != 0) {
          output.writeUInt32(4, waitBluetoothSecs_);
        }
        if (screenOnSecs_ != 0) {
          output.writeUInt32(5, screenOnSecs_);
        }
        if (phoneTimeoutSecs_ != 0) {
          output.writeUInt32(6, phoneTimeoutSecs_);
        }
        if (phoneSdsTimeoutSec_ != 0) {
          output.writeUInt32(7, phoneSdsTimeoutSec_);
        }
        if (meshSdsTimeoutSecs_ != 0) {
          output.writeUInt32(8, meshSdsTimeoutSecs_);
        }
        if (sdsSecs_ != 0) {
          output.writeUInt32(9, sdsSecs_);
        }
        if (lsSecs_ != 0) {
          output.writeUInt32(10, lsSecs_);
        }
        if (minWakeSecs_ != 0) {
          output.writeUInt32(11, minWakeSecs_);
        }
        if (!getWifiSsidBytes().isEmpty()) {
          com.google.protobuf.GeneratedMessageV3.writeString(output, 12, wifiSsid_);
        }
        if (!getWifiPasswordBytes().isEmpty()) {
          com.google.protobuf.GeneratedMessageV3.writeString(output, 13, wifiPassword_);
        }
        if (wifiApMode_ != false) {
          output.writeBool(14, wifiApMode_);
        }
        if (region_ != com.geeksville.mesh.RadioConfigProtos.RegionCode.Unset.getNumber()) {
          output.writeEnum(15, region_);
        }
        if (chargeCurrent_ != com.geeksville.mesh.RadioConfigProtos.ChargeCurrent.MAUnset.getNumber()) {
          output.writeEnum(16, chargeCurrent_);
        }
        if (locationShare_ != com.geeksville.mesh.RadioConfigProtos.LocationSharing.LocUnset.getNumber()) {
          output.writeEnum(32, locationShare_);
        }
        if (gpsOperation_ != com.geeksville.mesh.RadioConfigProtos.GpsOperation.GpsOpUnset.getNumber()) {
          output.writeEnum(33, gpsOperation_);
        }
        if (gpsUpdateInterval_ != 0) {
          output.writeUInt32(34, gpsUpdateInterval_);
        }
        if (gpsAttemptTime_ != 0) {
          output.writeUInt32(36, gpsAttemptTime_);
        }
        if (isRouter_ != false) {
          output.writeBool(37, isRouter_);
        }
        if (isLowPower_ != false) {
          output.writeBool(38, isLowPower_);
        }
        if (fixedPosition_ != false) {
          output.writeBool(39, fixedPosition_);
        }
        if (serialDisabled_ != false) {
          output.writeBool(40, serialDisabled_);
        }
        if (frequencyOffset_ != 0F) {
          output.writeFloat(41, frequencyOffset_);
        }
        if (!getMqttServerBytes().isEmpty()) {
          com.google.protobuf.GeneratedMessageV3.writeString(output, 42, mqttServer_);
        }
        if (mqttDisabled_ != false) {
          output.writeBool(43, mqttDisabled_);
        }
        if (factoryReset_ != false) {
          output.writeBool(100, factoryReset_);
        }
        if (debugLogEnabled_ != false) {
          output.writeBool(101, debugLogEnabled_);
        }
        if (getIgnoreIncomingList().size() > 0) {
          output.writeUInt32NoTag(826);
          output.writeUInt32NoTag(ignoreIncomingMemoizedSerializedSize);
        }
        for (int i = 0; i < ignoreIncoming_.size(); i++) {
          output.writeUInt32NoTag(ignoreIncoming_.getInt(i));
        }
        if (serialpluginEnabled_ != false) {
          output.writeBool(120, serialpluginEnabled_);
        }
        if (serialpluginEcho_ != false) {
          output.writeBool(121, serialpluginEcho_);
        }
        if (serialpluginRxd_ != 0) {
          output.writeUInt32(122, serialpluginRxd_);
        }
        if (serialpluginTxd_ != 0) {
          output.writeUInt32(123, serialpluginTxd_);
        }
        if (serialpluginTimeout_ != 0) {
          output.writeUInt32(124, serialpluginTimeout_);
        }
        if (serialpluginMode_ != 0) {
          output.writeUInt32(125, serialpluginMode_);
        }
        if (extNotificationPluginEnabled_ != false) {
          output.writeBool(126, extNotificationPluginEnabled_);
        }
        if (extNotificationPluginOutputMs_ != 0) {
          output.writeUInt32(127, extNotificationPluginOutputMs_);
        }
        if (extNotificationPluginOutput_ != 0) {
          output.writeUInt32(128, extNotificationPluginOutput_);
        }
        if (extNotificationPluginActive_ != false) {
          output.writeBool(129, extNotificationPluginActive_);
        }
        if (extNotificationPluginAlertMessage_ != false) {
          output.writeBool(130, extNotificationPluginAlertMessage_);
        }
        if (extNotificationPluginAlertBell_ != false) {
          output.writeBool(131, extNotificationPluginAlertBell_);
        }
        if (rangeTestPluginEnabled_ != false) {
          output.writeBool(132, rangeTestPluginEnabled_);
        }
        if (rangeTestPluginSender_ != 0) {
          output.writeUInt32(133, rangeTestPluginSender_);
        }
        if (rangeTestPluginSave_ != false) {
          output.writeBool(134, rangeTestPluginSave_);
        }
        if (storeForwardPluginRecords_ != 0) {
          output.writeUInt32(137, storeForwardPluginRecords_);
        }
        if (environmentalMeasurementPluginMeasurementEnabled_ != false) {
          output.writeBool(140, environmentalMeasurementPluginMeasurementEnabled_);
        }
        if (environmentalMeasurementPluginScreenEnabled_ != false) {
          output.writeBool(141, environmentalMeasurementPluginScreenEnabled_);
        }
        if (environmentalMeasurementPluginReadErrorCountThreshold_ != 0) {
          output.writeUInt32(142, environmentalMeasurementPluginReadErrorCountThreshold_);
        }
        if (environmentalMeasurementPluginUpdateInterval_ != 0) {
          output.writeUInt32(143, environmentalMeasurementPluginUpdateInterval_);
        }
        if (environmentalMeasurementPluginRecoveryInterval_ != 0) {
          output.writeUInt32(144, environmentalMeasurementPluginRecoveryInterval_);
        }
        if (environmentalMeasurementPluginDisplayFarenheit_ != false) {
          output.writeBool(145, environmentalMeasurementPluginDisplayFarenheit_);
        }
        if (environmentalMeasurementPluginSensorType_ != com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences.EnvironmentalMeasurementSensorType.DHT11.getNumber()) {
          output.writeEnum(146, environmentalMeasurementPluginSensorType_);
        }
        if (environmentalMeasurementPluginSensorPin_ != 0) {
          output.writeUInt32(147, environmentalMeasurementPluginSensorPin_);
        }
        if (storeForwardPluginEnabled_ != false) {
          output.writeBool(148, storeForwardPluginEnabled_);
        }
        unknownFields.writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (positionBroadcastSecs_ != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(1, positionBroadcastSecs_);
        }
        if (sendOwnerInterval_ != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(2, sendOwnerInterval_);
        }
        if (waitBluetoothSecs_ != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(4, waitBluetoothSecs_);
        }
        if (screenOnSecs_ != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(5, screenOnSecs_);
        }
        if (phoneTimeoutSecs_ != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(6, phoneTimeoutSecs_);
        }
        if (phoneSdsTimeoutSec_ != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(7, phoneSdsTimeoutSec_);
        }
        if (meshSdsTimeoutSecs_ != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(8, meshSdsTimeoutSecs_);
        }
        if (sdsSecs_ != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(9, sdsSecs_);
        }
        if (lsSecs_ != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(10, lsSecs_);
        }
        if (minWakeSecs_ != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(11, minWakeSecs_);
        }
        if (!getWifiSsidBytes().isEmpty()) {
          size += com.google.protobuf.GeneratedMessageV3.computeStringSize(12, wifiSsid_);
        }
        if (!getWifiPasswordBytes().isEmpty()) {
          size += com.google.protobuf.GeneratedMessageV3.computeStringSize(13, wifiPassword_);
        }
        if (wifiApMode_ != false) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(14, wifiApMode_);
        }
        if (region_ != com.geeksville.mesh.RadioConfigProtos.RegionCode.Unset.getNumber()) {
          size += com.google.protobuf.CodedOutputStream
            .computeEnumSize(15, region_);
        }
        if (chargeCurrent_ != com.geeksville.mesh.RadioConfigProtos.ChargeCurrent.MAUnset.getNumber()) {
          size += com.google.protobuf.CodedOutputStream
            .computeEnumSize(16, chargeCurrent_);
        }
        if (locationShare_ != com.geeksville.mesh.RadioConfigProtos.LocationSharing.LocUnset.getNumber()) {
          size += com.google.protobuf.CodedOutputStream
            .computeEnumSize(32, locationShare_);
        }
        if (gpsOperation_ != com.geeksville.mesh.RadioConfigProtos.GpsOperation.GpsOpUnset.getNumber()) {
          size += com.google.protobuf.CodedOutputStream
            .computeEnumSize(33, gpsOperation_);
        }
        if (gpsUpdateInterval_ != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(34, gpsUpdateInterval_);
        }
        if (gpsAttemptTime_ != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(36, gpsAttemptTime_);
        }
        if (isRouter_ != false) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(37, isRouter_);
        }
        if (isLowPower_ != false) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(38, isLowPower_);
        }
        if (fixedPosition_ != false) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(39, fixedPosition_);
        }
        if (serialDisabled_ != false) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(40, serialDisabled_);
        }
        if (frequencyOffset_ != 0F) {
          size += com.google.protobuf.CodedOutputStream
            .computeFloatSize(41, frequencyOffset_);
        }
        if (!getMqttServerBytes().isEmpty()) {
          size += com.google.protobuf.GeneratedMessageV3.computeStringSize(42, mqttServer_);
        }
        if (mqttDisabled_ != false) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(43, mqttDisabled_);
        }
        if (factoryReset_ != false) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(100, factoryReset_);
        }
        if (debugLogEnabled_ != false) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(101, debugLogEnabled_);
        }
        {
          int dataSize = 0;
          for (int i = 0; i < ignoreIncoming_.size(); i++) {
            dataSize += com.google.protobuf.CodedOutputStream
              .computeUInt32SizeNoTag(ignoreIncoming_.getInt(i));
          }
          size += dataSize;
          if (!getIgnoreIncomingList().isEmpty()) {
            size += 2;
            size += com.google.protobuf.CodedOutputStream
                .computeInt32SizeNoTag(dataSize);
          }
          ignoreIncomingMemoizedSerializedSize = dataSize;
        }
        if (serialpluginEnabled_ != false) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(120, serialpluginEnabled_);
        }
        if (serialpluginEcho_ != false) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(121, serialpluginEcho_);
        }
        if (serialpluginRxd_ != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(122, serialpluginRxd_);
        }
        if (serialpluginTxd_ != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(123, serialpluginTxd_);
        }
        if (serialpluginTimeout_ != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(124, serialpluginTimeout_);
        }
        if (serialpluginMode_ != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(125, serialpluginMode_);
        }
        if (extNotificationPluginEnabled_ != false) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(126, extNotificationPluginEnabled_);
        }
        if (extNotificationPluginOutputMs_ != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(127, extNotificationPluginOutputMs_);
        }
        if (extNotificationPluginOutput_ != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(128, extNotificationPluginOutput_);
        }
        if (extNotificationPluginActive_ != false) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(129, extNotificationPluginActive_);
        }
        if (extNotificationPluginAlertMessage_ != false) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(130, extNotificationPluginAlertMessage_);
        }
        if (extNotificationPluginAlertBell_ != false) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(131, extNotificationPluginAlertBell_);
        }
        if (rangeTestPluginEnabled_ != false) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(132, rangeTestPluginEnabled_);
        }
        if (rangeTestPluginSender_ != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(133, rangeTestPluginSender_);
        }
        if (rangeTestPluginSave_ != false) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(134, rangeTestPluginSave_);
        }
        if (storeForwardPluginRecords_ != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(137, storeForwardPluginRecords_);
        }
        if (environmentalMeasurementPluginMeasurementEnabled_ != false) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(140, environmentalMeasurementPluginMeasurementEnabled_);
        }
        if (environmentalMeasurementPluginScreenEnabled_ != false) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(141, environmentalMeasurementPluginScreenEnabled_);
        }
        if (environmentalMeasurementPluginReadErrorCountThreshold_ != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(142, environmentalMeasurementPluginReadErrorCountThreshold_);
        }
        if (environmentalMeasurementPluginUpdateInterval_ != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(143, environmentalMeasurementPluginUpdateInterval_);
        }
        if (environmentalMeasurementPluginRecoveryInterval_ != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(144, environmentalMeasurementPluginRecoveryInterval_);
        }
        if (environmentalMeasurementPluginDisplayFarenheit_ != false) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(145, environmentalMeasurementPluginDisplayFarenheit_);
        }
        if (environmentalMeasurementPluginSensorType_ != com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences.EnvironmentalMeasurementSensorType.DHT11.getNumber()) {
          size += com.google.protobuf.CodedOutputStream
            .computeEnumSize(146, environmentalMeasurementPluginSensorType_);
        }
        if (environmentalMeasurementPluginSensorPin_ != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(147, environmentalMeasurementPluginSensorPin_);
        }
        if (storeForwardPluginEnabled_ != false) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(148, storeForwardPluginEnabled_);
        }
        size += unknownFields.getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences)) {
          return super.equals(obj);
        }
        com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences other = (com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences) obj;

        if (getPositionBroadcastSecs()
            != other.getPositionBroadcastSecs()) return false;
        if (getSendOwnerInterval()
            != other.getSendOwnerInterval()) return false;
        if (getWaitBluetoothSecs()
            != other.getWaitBluetoothSecs()) return false;
        if (getScreenOnSecs()
            != other.getScreenOnSecs()) return false;
        if (getPhoneTimeoutSecs()
            != other.getPhoneTimeoutSecs()) return false;
        if (getPhoneSdsTimeoutSec()
            != other.getPhoneSdsTimeoutSec()) return false;
        if (getMeshSdsTimeoutSecs()
            != other.getMeshSdsTimeoutSecs()) return false;
        if (getSdsSecs()
            != other.getSdsSecs()) return false;
        if (getLsSecs()
            != other.getLsSecs()) return false;
        if (getMinWakeSecs()
            != other.getMinWakeSecs()) return false;
        if (!getWifiSsid()
            .equals(other.getWifiSsid())) return false;
        if (!getWifiPassword()
            .equals(other.getWifiPassword())) return false;
        if (getWifiApMode()
            != other.getWifiApMode()) return false;
        if (region_ != other.region_) return false;
        if (chargeCurrent_ != other.chargeCurrent_) return false;
        if (getIsRouter()
            != other.getIsRouter()) return false;
        if (getIsLowPower()
            != other.getIsLowPower()) return false;
        if (getFixedPosition()
            != other.getFixedPosition()) return false;
        if (getSerialDisabled()
            != other.getSerialDisabled()) return false;
        if (locationShare_ != other.locationShare_) return false;
        if (gpsOperation_ != other.gpsOperation_) return false;
        if (getGpsUpdateInterval()
            != other.getGpsUpdateInterval()) return false;
        if (getGpsAttemptTime()
            != other.getGpsAttemptTime()) return false;
        if (java.lang.Float.floatToIntBits(getFrequencyOffset())
            != java.lang.Float.floatToIntBits(
                other.getFrequencyOffset())) return false;
        if (!getMqttServer()
            .equals(other.getMqttServer())) return false;
        if (getMqttDisabled()
            != other.getMqttDisabled()) return false;
        if (getFactoryReset()
            != other.getFactoryReset()) return false;
        if (getDebugLogEnabled()
            != other.getDebugLogEnabled()) return false;
        if (!getIgnoreIncomingList()
            .equals(other.getIgnoreIncomingList())) return false;
        if (getSerialpluginEnabled()
            != other.getSerialpluginEnabled()) return false;
        if (getSerialpluginEcho()
            != other.getSerialpluginEcho()) return false;
        if (getSerialpluginRxd()
            != other.getSerialpluginRxd()) return false;
        if (getSerialpluginTxd()
            != other.getSerialpluginTxd()) return false;
        if (getSerialpluginTimeout()
            != other.getSerialpluginTimeout()) return false;
        if (getSerialpluginMode()
            != other.getSerialpluginMode()) return false;
        if (getExtNotificationPluginEnabled()
            != other.getExtNotificationPluginEnabled()) return false;
        if (getExtNotificationPluginOutputMs()
            != other.getExtNotificationPluginOutputMs()) return false;
        if (getExtNotificationPluginOutput()
            != other.getExtNotificationPluginOutput()) return false;
        if (getExtNotificationPluginActive()
            != other.getExtNotificationPluginActive()) return false;
        if (getExtNotificationPluginAlertMessage()
            != other.getExtNotificationPluginAlertMessage()) return false;
        if (getExtNotificationPluginAlertBell()
            != other.getExtNotificationPluginAlertBell()) return false;
        if (getRangeTestPluginEnabled()
            != other.getRangeTestPluginEnabled()) return false;
        if (getRangeTestPluginSender()
            != other.getRangeTestPluginSender()) return false;
        if (getRangeTestPluginSave()
            != other.getRangeTestPluginSave()) return false;
        if (getStoreForwardPluginEnabled()
            != other.getStoreForwardPluginEnabled()) return false;
        if (getStoreForwardPluginRecords()
            != other.getStoreForwardPluginRecords()) return false;
        if (getEnvironmentalMeasurementPluginMeasurementEnabled()
            != other.getEnvironmentalMeasurementPluginMeasurementEnabled()) return false;
        if (getEnvironmentalMeasurementPluginScreenEnabled()
            != other.getEnvironmentalMeasurementPluginScreenEnabled()) return false;
        if (getEnvironmentalMeasurementPluginReadErrorCountThreshold()
            != other.getEnvironmentalMeasurementPluginReadErrorCountThreshold()) return false;
        if (getEnvironmentalMeasurementPluginUpdateInterval()
            != other.getEnvironmentalMeasurementPluginUpdateInterval()) return false;
        if (getEnvironmentalMeasurementPluginRecoveryInterval()
            != other.getEnvironmentalMeasurementPluginRecoveryInterval()) return false;
        if (getEnvironmentalMeasurementPluginDisplayFarenheit()
            != other.getEnvironmentalMeasurementPluginDisplayFarenheit()) return false;
        if (environmentalMeasurementPluginSensorType_ != other.environmentalMeasurementPluginSensorType_) return false;
        if (getEnvironmentalMeasurementPluginSensorPin()
            != other.getEnvironmentalMeasurementPluginSensorPin()) return false;
        if (!unknownFields.equals(other.unknownFields)) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        hash = (37 * hash) + POSITION_BROADCAST_SECS_FIELD_NUMBER;
        hash = (53 * hash) + getPositionBroadcastSecs();
        hash = (37 * hash) + SEND_OWNER_INTERVAL_FIELD_NUMBER;
        hash = (53 * hash) + getSendOwnerInterval();
        hash = (37 * hash) + WAIT_BLUETOOTH_SECS_FIELD_NUMBER;
        hash = (53 * hash) + getWaitBluetoothSecs();
        hash = (37 * hash) + SCREEN_ON_SECS_FIELD_NUMBER;
        hash = (53 * hash) + getScreenOnSecs();
        hash = (37 * hash) + PHONE_TIMEOUT_SECS_FIELD_NUMBER;
        hash = (53 * hash) + getPhoneTimeoutSecs();
        hash = (37 * hash) + PHONE_SDS_TIMEOUT_SEC_FIELD_NUMBER;
        hash = (53 * hash) + getPhoneSdsTimeoutSec();
        hash = (37 * hash) + MESH_SDS_TIMEOUT_SECS_FIELD_NUMBER;
        hash = (53 * hash) + getMeshSdsTimeoutSecs();
        hash = (37 * hash) + SDS_SECS_FIELD_NUMBER;
        hash = (53 * hash) + getSdsSecs();
        hash = (37 * hash) + LS_SECS_FIELD_NUMBER;
        hash = (53 * hash) + getLsSecs();
        hash = (37 * hash) + MIN_WAKE_SECS_FIELD_NUMBER;
        hash = (53 * hash) + getMinWakeSecs();
        hash = (37 * hash) + WIFI_SSID_FIELD_NUMBER;
        hash = (53 * hash) + getWifiSsid().hashCode();
        hash = (37 * hash) + WIFI_PASSWORD_FIELD_NUMBER;
        hash = (53 * hash) + getWifiPassword().hashCode();
        hash = (37 * hash) + WIFI_AP_MODE_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getWifiApMode());
        hash = (37 * hash) + REGION_FIELD_NUMBER;
        hash = (53 * hash) + region_;
        hash = (37 * hash) + CHARGE_CURRENT_FIELD_NUMBER;
        hash = (53 * hash) + chargeCurrent_;
        hash = (37 * hash) + IS_ROUTER_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getIsRouter());
        hash = (37 * hash) + IS_LOW_POWER_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getIsLowPower());
        hash = (37 * hash) + FIXED_POSITION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getFixedPosition());
        hash = (37 * hash) + SERIAL_DISABLED_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getSerialDisabled());
        hash = (37 * hash) + LOCATION_SHARE_FIELD_NUMBER;
        hash = (53 * hash) + locationShare_;
        hash = (37 * hash) + GPS_OPERATION_FIELD_NUMBER;
        hash = (53 * hash) + gpsOperation_;
        hash = (37 * hash) + GPS_UPDATE_INTERVAL_FIELD_NUMBER;
        hash = (53 * hash) + getGpsUpdateInterval();
        hash = (37 * hash) + GPS_ATTEMPT_TIME_FIELD_NUMBER;
        hash = (53 * hash) + getGpsAttemptTime();
        hash = (37 * hash) + FREQUENCY_OFFSET_FIELD_NUMBER;
        hash = (53 * hash) + java.lang.Float.floatToIntBits(
            getFrequencyOffset());
        hash = (37 * hash) + MQTT_SERVER_FIELD_NUMBER;
        hash = (53 * hash) + getMqttServer().hashCode();
        hash = (37 * hash) + MQTT_DISABLED_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getMqttDisabled());
        hash = (37 * hash) + FACTORY_RESET_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getFactoryReset());
        hash = (37 * hash) + DEBUG_LOG_ENABLED_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getDebugLogEnabled());
        if (getIgnoreIncomingCount() > 0) {
          hash = (37 * hash) + IGNORE_INCOMING_FIELD_NUMBER;
          hash = (53 * hash) + getIgnoreIncomingList().hashCode();
        }
        hash = (37 * hash) + SERIALPLUGIN_ENABLED_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getSerialpluginEnabled());
        hash = (37 * hash) + SERIALPLUGIN_ECHO_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getSerialpluginEcho());
        hash = (37 * hash) + SERIALPLUGIN_RXD_FIELD_NUMBER;
        hash = (53 * hash) + getSerialpluginRxd();
        hash = (37 * hash) + SERIALPLUGIN_TXD_FIELD_NUMBER;
        hash = (53 * hash) + getSerialpluginTxd();
        hash = (37 * hash) + SERIALPLUGIN_TIMEOUT_FIELD_NUMBER;
        hash = (53 * hash) + getSerialpluginTimeout();
        hash = (37 * hash) + SERIALPLUGIN_MODE_FIELD_NUMBER;
        hash = (53 * hash) + getSerialpluginMode();
        hash = (37 * hash) + EXT_NOTIFICATION_PLUGIN_ENABLED_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getExtNotificationPluginEnabled());
        hash = (37 * hash) + EXT_NOTIFICATION_PLUGIN_OUTPUT_MS_FIELD_NUMBER;
        hash = (53 * hash) + getExtNotificationPluginOutputMs();
        hash = (37 * hash) + EXT_NOTIFICATION_PLUGIN_OUTPUT_FIELD_NUMBER;
        hash = (53 * hash) + getExtNotificationPluginOutput();
        hash = (37 * hash) + EXT_NOTIFICATION_PLUGIN_ACTIVE_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getExtNotificationPluginActive());
        hash = (37 * hash) + EXT_NOTIFICATION_PLUGIN_ALERT_MESSAGE_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getExtNotificationPluginAlertMessage());
        hash = (37 * hash) + EXT_NOTIFICATION_PLUGIN_ALERT_BELL_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getExtNotificationPluginAlertBell());
        hash = (37 * hash) + RANGE_TEST_PLUGIN_ENABLED_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getRangeTestPluginEnabled());
        hash = (37 * hash) + RANGE_TEST_PLUGIN_SENDER_FIELD_NUMBER;
        hash = (53 * hash) + getRangeTestPluginSender();
        hash = (37 * hash) + RANGE_TEST_PLUGIN_SAVE_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getRangeTestPluginSave());
        hash = (37 * hash) + STORE_FORWARD_PLUGIN_ENABLED_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getStoreForwardPluginEnabled());
        hash = (37 * hash) + STORE_FORWARD_PLUGIN_RECORDS_FIELD_NUMBER;
        hash = (53 * hash) + getStoreForwardPluginRecords();
        hash = (37 * hash) + ENVIRONMENTAL_MEASUREMENT_PLUGIN_MEASUREMENT_ENABLED_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getEnvironmentalMeasurementPluginMeasurementEnabled());
        hash = (37 * hash) + ENVIRONMENTAL_MEASUREMENT_PLUGIN_SCREEN_ENABLED_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getEnvironmentalMeasurementPluginScreenEnabled());
        hash = (37 * hash) + ENVIRONMENTAL_MEASUREMENT_PLUGIN_READ_ERROR_COUNT_THRESHOLD_FIELD_NUMBER;
        hash = (53 * hash) + getEnvironmentalMeasurementPluginReadErrorCountThreshold();
        hash = (37 * hash) + ENVIRONMENTAL_MEASUREMENT_PLUGIN_UPDATE_INTERVAL_FIELD_NUMBER;
        hash = (53 * hash) + getEnvironmentalMeasurementPluginUpdateInterval();
        hash = (37 * hash) + ENVIRONMENTAL_MEASUREMENT_PLUGIN_RECOVERY_INTERVAL_FIELD_NUMBER;
        hash = (53 * hash) + getEnvironmentalMeasurementPluginRecoveryInterval();
        hash = (37 * hash) + ENVIRONMENTAL_MEASUREMENT_PLUGIN_DISPLAY_FARENHEIT_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getEnvironmentalMeasurementPluginDisplayFarenheit());
        hash = (37 * hash) + ENVIRONMENTAL_MEASUREMENT_PLUGIN_SENSOR_TYPE_FIELD_NUMBER;
        hash = (53 * hash) + environmentalMeasurementPluginSensorType_;
        hash = (37 * hash) + ENVIRONMENTAL_MEASUREMENT_PLUGIN_SENSOR_PIN_FIELD_NUMBER;
        hash = (53 * hash) + getEnvironmentalMeasurementPluginSensorPin();
        hash = (29 * hash) + unknownFields.hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * <pre>
       * see [software design](/software/other/sw-design.md) for more information on these preferences
       * </pre>
       *
       * Protobuf type {@code RadioConfig.UserPreferences}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:RadioConfig.UserPreferences)
          com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferencesOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return com.geeksville.mesh.RadioConfigProtos.internal_static_RadioConfig_UserPreferences_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return com.geeksville.mesh.RadioConfigProtos.internal_static_RadioConfig_UserPreferences_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences.class, com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences.Builder.class);
        }

        // Construct using com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (com.google.protobuf.GeneratedMessageV3
                  .alwaysUseFieldBuilders) {
          }
        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          positionBroadcastSecs_ = 0;

          sendOwnerInterval_ = 0;

          waitBluetoothSecs_ = 0;

          screenOnSecs_ = 0;

          phoneTimeoutSecs_ = 0;

          phoneSdsTimeoutSec_ = 0;

          meshSdsTimeoutSecs_ = 0;

          sdsSecs_ = 0;

          lsSecs_ = 0;

          minWakeSecs_ = 0;

          wifiSsid_ = "";

          wifiPassword_ = "";

          wifiApMode_ = false;

          region_ = 0;

          chargeCurrent_ = 0;

          isRouter_ = false;

          isLowPower_ = false;

          fixedPosition_ = false;

          serialDisabled_ = false;

          locationShare_ = 0;

          gpsOperation_ = 0;

          gpsUpdateInterval_ = 0;

          gpsAttemptTime_ = 0;

          frequencyOffset_ = 0F;

          mqttServer_ = "";

          mqttDisabled_ = false;

          factoryReset_ = false;

          debugLogEnabled_ = false;

          ignoreIncoming_ = emptyIntList();
          bitField0_ = (bitField0_ & ~0x00000001);
          serialpluginEnabled_ = false;

          serialpluginEcho_ = false;

          serialpluginRxd_ = 0;

          serialpluginTxd_ = 0;

          serialpluginTimeout_ = 0;

          serialpluginMode_ = 0;

          extNotificationPluginEnabled_ = false;

          extNotificationPluginOutputMs_ = 0;

          extNotificationPluginOutput_ = 0;

          extNotificationPluginActive_ = false;

          extNotificationPluginAlertMessage_ = false;

          extNotificationPluginAlertBell_ = false;

          rangeTestPluginEnabled_ = false;

          rangeTestPluginSender_ = 0;

          rangeTestPluginSave_ = false;

          storeForwardPluginEnabled_ = false;

          storeForwardPluginRecords_ = 0;

          environmentalMeasurementPluginMeasurementEnabled_ = false;

          environmentalMeasurementPluginScreenEnabled_ = false;

          environmentalMeasurementPluginReadErrorCountThreshold_ = 0;

          environmentalMeasurementPluginUpdateInterval_ = 0;

          environmentalMeasurementPluginRecoveryInterval_ = 0;

          environmentalMeasurementPluginDisplayFarenheit_ = false;

          environmentalMeasurementPluginSensorType_ = 0;

          environmentalMeasurementPluginSensorPin_ = 0;

          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return com.geeksville.mesh.RadioConfigProtos.internal_static_RadioConfig_UserPreferences_descriptor;
        }

        @java.lang.Override
        public com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences getDefaultInstanceForType() {
          return com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences.getDefaultInstance();
        }

        @java.lang.Override
        public com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences build() {
          com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences buildPartial() {
          com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences result = new com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences(this);
          int from_bitField0_ = bitField0_;
          result.positionBroadcastSecs_ = positionBroadcastSecs_;
          result.sendOwnerInterval_ = sendOwnerInterval_;
          result.waitBluetoothSecs_ = waitBluetoothSecs_;
          result.screenOnSecs_ = screenOnSecs_;
          result.phoneTimeoutSecs_ = phoneTimeoutSecs_;
          result.phoneSdsTimeoutSec_ = phoneSdsTimeoutSec_;
          result.meshSdsTimeoutSecs_ = meshSdsTimeoutSecs_;
          result.sdsSecs_ = sdsSecs_;
          result.lsSecs_ = lsSecs_;
          result.minWakeSecs_ = minWakeSecs_;
          result.wifiSsid_ = wifiSsid_;
          result.wifiPassword_ = wifiPassword_;
          result.wifiApMode_ = wifiApMode_;
          result.region_ = region_;
          result.chargeCurrent_ = chargeCurrent_;
          result.isRouter_ = isRouter_;
          result.isLowPower_ = isLowPower_;
          result.fixedPosition_ = fixedPosition_;
          result.serialDisabled_ = serialDisabled_;
          result.locationShare_ = locationShare_;
          result.gpsOperation_ = gpsOperation_;
          result.gpsUpdateInterval_ = gpsUpdateInterval_;
          result.gpsAttemptTime_ = gpsAttemptTime_;
          result.frequencyOffset_ = frequencyOffset_;
          result.mqttServer_ = mqttServer_;
          result.mqttDisabled_ = mqttDisabled_;
          result.factoryReset_ = factoryReset_;
          result.debugLogEnabled_ = debugLogEnabled_;
          if (((bitField0_ & 0x00000001) != 0)) {
            ignoreIncoming_.makeImmutable();
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.ignoreIncoming_ = ignoreIncoming_;
          result.serialpluginEnabled_ = serialpluginEnabled_;
          result.serialpluginEcho_ = serialpluginEcho_;
          result.serialpluginRxd_ = serialpluginRxd_;
          result.serialpluginTxd_ = serialpluginTxd_;
          result.serialpluginTimeout_ = serialpluginTimeout_;
          result.serialpluginMode_ = serialpluginMode_;
          result.extNotificationPluginEnabled_ = extNotificationPluginEnabled_;
          result.extNotificationPluginOutputMs_ = extNotificationPluginOutputMs_;
          result.extNotificationPluginOutput_ = extNotificationPluginOutput_;
          result.extNotificationPluginActive_ = extNotificationPluginActive_;
          result.extNotificationPluginAlertMessage_ = extNotificationPluginAlertMessage_;
          result.extNotificationPluginAlertBell_ = extNotificationPluginAlertBell_;
          result.rangeTestPluginEnabled_ = rangeTestPluginEnabled_;
          result.rangeTestPluginSender_ = rangeTestPluginSender_;
          result.rangeTestPluginSave_ = rangeTestPluginSave_;
          result.storeForwardPluginEnabled_ = storeForwardPluginEnabled_;
          result.storeForwardPluginRecords_ = storeForwardPluginRecords_;
          result.environmentalMeasurementPluginMeasurementEnabled_ = environmentalMeasurementPluginMeasurementEnabled_;
          result.environmentalMeasurementPluginScreenEnabled_ = environmentalMeasurementPluginScreenEnabled_;
          result.environmentalMeasurementPluginReadErrorCountThreshold_ = environmentalMeasurementPluginReadErrorCountThreshold_;
          result.environmentalMeasurementPluginUpdateInterval_ = environmentalMeasurementPluginUpdateInterval_;
          result.environmentalMeasurementPluginRecoveryInterval_ = environmentalMeasurementPluginRecoveryInterval_;
          result.environmentalMeasurementPluginDisplayFarenheit_ = environmentalMeasurementPluginDisplayFarenheit_;
          result.environmentalMeasurementPluginSensorType_ = environmentalMeasurementPluginSensorType_;
          result.environmentalMeasurementPluginSensorPin_ = environmentalMeasurementPluginSensorPin_;
          onBuilt();
          return result;
        }

        @java.lang.Override
        public Builder clone() {
          return super.clone();
        }
        @java.lang.Override
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.setField(field, value);
        }
        @java.lang.Override
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return super.clearField(field);
        }
        @java.lang.Override
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return super.clearOneof(oneof);
        }
        @java.lang.Override
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return super.setRepeatedField(field, index, value);
        }
        @java.lang.Override
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.addRepeatedField(field, value);
        }
        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences) {
            return mergeFrom((com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences other) {
          if (other == com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences.getDefaultInstance()) return this;
          if (other.getPositionBroadcastSecs() != 0) {
            setPositionBroadcastSecs(other.getPositionBroadcastSecs());
          }
          if (other.getSendOwnerInterval() != 0) {
            setSendOwnerInterval(other.getSendOwnerInterval());
          }
          if (other.getWaitBluetoothSecs() != 0) {
            setWaitBluetoothSecs(other.getWaitBluetoothSecs());
          }
          if (other.getScreenOnSecs() != 0) {
            setScreenOnSecs(other.getScreenOnSecs());
          }
          if (other.getPhoneTimeoutSecs() != 0) {
            setPhoneTimeoutSecs(other.getPhoneTimeoutSecs());
          }
          if (other.getPhoneSdsTimeoutSec() != 0) {
            setPhoneSdsTimeoutSec(other.getPhoneSdsTimeoutSec());
          }
          if (other.getMeshSdsTimeoutSecs() != 0) {
            setMeshSdsTimeoutSecs(other.getMeshSdsTimeoutSecs());
          }
          if (other.getSdsSecs() != 0) {
            setSdsSecs(other.getSdsSecs());
          }
          if (other.getLsSecs() != 0) {
            setLsSecs(other.getLsSecs());
          }
          if (other.getMinWakeSecs() != 0) {
            setMinWakeSecs(other.getMinWakeSecs());
          }
          if (!other.getWifiSsid().isEmpty()) {
            wifiSsid_ = other.wifiSsid_;
            onChanged();
          }
          if (!other.getWifiPassword().isEmpty()) {
            wifiPassword_ = other.wifiPassword_;
            onChanged();
          }
          if (other.getWifiApMode() != false) {
            setWifiApMode(other.getWifiApMode());
          }
          if (other.region_ != 0) {
            setRegionValue(other.getRegionValue());
          }
          if (other.chargeCurrent_ != 0) {
            setChargeCurrentValue(other.getChargeCurrentValue());
          }
          if (other.getIsRouter() != false) {
            setIsRouter(other.getIsRouter());
          }
          if (other.getIsLowPower() != false) {
            setIsLowPower(other.getIsLowPower());
          }
          if (other.getFixedPosition() != false) {
            setFixedPosition(other.getFixedPosition());
          }
          if (other.getSerialDisabled() != false) {
            setSerialDisabled(other.getSerialDisabled());
          }
          if (other.locationShare_ != 0) {
            setLocationShareValue(other.getLocationShareValue());
          }
          if (other.gpsOperation_ != 0) {
            setGpsOperationValue(other.getGpsOperationValue());
          }
          if (other.getGpsUpdateInterval() != 0) {
            setGpsUpdateInterval(other.getGpsUpdateInterval());
          }
          if (other.getGpsAttemptTime() != 0) {
            setGpsAttemptTime(other.getGpsAttemptTime());
          }
          if (other.getFrequencyOffset() != 0F) {
            setFrequencyOffset(other.getFrequencyOffset());
          }
          if (!other.getMqttServer().isEmpty()) {
            mqttServer_ = other.mqttServer_;
            onChanged();
          }
          if (other.getMqttDisabled() != false) {
            setMqttDisabled(other.getMqttDisabled());
          }
          if (other.getFactoryReset() != false) {
            setFactoryReset(other.getFactoryReset());
          }
          if (other.getDebugLogEnabled() != false) {
            setDebugLogEnabled(other.getDebugLogEnabled());
          }
          if (!other.ignoreIncoming_.isEmpty()) {
            if (ignoreIncoming_.isEmpty()) {
              ignoreIncoming_ = other.ignoreIncoming_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureIgnoreIncomingIsMutable();
              ignoreIncoming_.addAll(other.ignoreIncoming_);
            }
            onChanged();
          }
          if (other.getSerialpluginEnabled() != false) {
            setSerialpluginEnabled(other.getSerialpluginEnabled());
          }
          if (other.getSerialpluginEcho() != false) {
            setSerialpluginEcho(other.getSerialpluginEcho());
          }
          if (other.getSerialpluginRxd() != 0) {
            setSerialpluginRxd(other.getSerialpluginRxd());
          }
          if (other.getSerialpluginTxd() != 0) {
            setSerialpluginTxd(other.getSerialpluginTxd());
          }
          if (other.getSerialpluginTimeout() != 0) {
            setSerialpluginTimeout(other.getSerialpluginTimeout());
          }
          if (other.getSerialpluginMode() != 0) {
            setSerialpluginMode(other.getSerialpluginMode());
          }
          if (other.getExtNotificationPluginEnabled() != false) {
            setExtNotificationPluginEnabled(other.getExtNotificationPluginEnabled());
          }
          if (other.getExtNotificationPluginOutputMs() != 0) {
            setExtNotificationPluginOutputMs(other.getExtNotificationPluginOutputMs());
          }
          if (other.getExtNotificationPluginOutput() != 0) {
            setExtNotificationPluginOutput(other.getExtNotificationPluginOutput());
          }
          if (other.getExtNotificationPluginActive() != false) {
            setExtNotificationPluginActive(other.getExtNotificationPluginActive());
          }
          if (other.getExtNotificationPluginAlertMessage() != false) {
            setExtNotificationPluginAlertMessage(other.getExtNotificationPluginAlertMessage());
          }
          if (other.getExtNotificationPluginAlertBell() != false) {
            setExtNotificationPluginAlertBell(other.getExtNotificationPluginAlertBell());
          }
          if (other.getRangeTestPluginEnabled() != false) {
            setRangeTestPluginEnabled(other.getRangeTestPluginEnabled());
          }
          if (other.getRangeTestPluginSender() != 0) {
            setRangeTestPluginSender(other.getRangeTestPluginSender());
          }
          if (other.getRangeTestPluginSave() != false) {
            setRangeTestPluginSave(other.getRangeTestPluginSave());
          }
          if (other.getStoreForwardPluginEnabled() != false) {
            setStoreForwardPluginEnabled(other.getStoreForwardPluginEnabled());
          }
          if (other.getStoreForwardPluginRecords() != 0) {
            setStoreForwardPluginRecords(other.getStoreForwardPluginRecords());
          }
          if (other.getEnvironmentalMeasurementPluginMeasurementEnabled() != false) {
            setEnvironmentalMeasurementPluginMeasurementEnabled(other.getEnvironmentalMeasurementPluginMeasurementEnabled());
          }
          if (other.getEnvironmentalMeasurementPluginScreenEnabled() != false) {
            setEnvironmentalMeasurementPluginScreenEnabled(other.getEnvironmentalMeasurementPluginScreenEnabled());
          }
          if (other.getEnvironmentalMeasurementPluginReadErrorCountThreshold() != 0) {
            setEnvironmentalMeasurementPluginReadErrorCountThreshold(other.getEnvironmentalMeasurementPluginReadErrorCountThreshold());
          }
          if (other.getEnvironmentalMeasurementPluginUpdateInterval() != 0) {
            setEnvironmentalMeasurementPluginUpdateInterval(other.getEnvironmentalMeasurementPluginUpdateInterval());
          }
          if (other.getEnvironmentalMeasurementPluginRecoveryInterval() != 0) {
            setEnvironmentalMeasurementPluginRecoveryInterval(other.getEnvironmentalMeasurementPluginRecoveryInterval());
          }
          if (other.getEnvironmentalMeasurementPluginDisplayFarenheit() != false) {
            setEnvironmentalMeasurementPluginDisplayFarenheit(other.getEnvironmentalMeasurementPluginDisplayFarenheit());
          }
          if (other.environmentalMeasurementPluginSensorType_ != 0) {
            setEnvironmentalMeasurementPluginSensorTypeValue(other.getEnvironmentalMeasurementPluginSensorTypeValue());
          }
          if (other.getEnvironmentalMeasurementPluginSensorPin() != 0) {
            setEnvironmentalMeasurementPluginSensorPin(other.getEnvironmentalMeasurementPluginSensorPin());
          }
          this.mergeUnknownFields(other.unknownFields);
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences parsedMessage = null;
          try {
            parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            parsedMessage = (com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences) e.getUnfinishedMessage();
            throw e.unwrapIOException();
          } finally {
            if (parsedMessage != null) {
              mergeFrom(parsedMessage);
            }
          }
          return this;
        }
        private int bitField0_;

        private int positionBroadcastSecs_ ;
        /**
         * <pre>
         * We should send our position this often (but only if it has changed significantly)
         * Defaults to 15 minutes
         * </pre>
         *
         * <code>uint32 position_broadcast_secs = 1;</code>
         * @return The positionBroadcastSecs.
         */
        @java.lang.Override
        public int getPositionBroadcastSecs() {
          return positionBroadcastSecs_;
        }
        /**
         * <pre>
         * We should send our position this often (but only if it has changed significantly)
         * Defaults to 15 minutes
         * </pre>
         *
         * <code>uint32 position_broadcast_secs = 1;</code>
         * @param value The positionBroadcastSecs to set.
         * @return This builder for chaining.
         */
        public Builder setPositionBroadcastSecs(int value) {
          
          positionBroadcastSecs_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * We should send our position this often (but only if it has changed significantly)
         * Defaults to 15 minutes
         * </pre>
         *
         * <code>uint32 position_broadcast_secs = 1;</code>
         * @return This builder for chaining.
         */
        public Builder clearPositionBroadcastSecs() {
          
          positionBroadcastSecs_ = 0;
          onChanged();
          return this;
        }

        private int sendOwnerInterval_ ;
        /**
         * <pre>
         * Send our owner info at least this often (also we always send once at boot - to rejoin the mesh)
         * </pre>
         *
         * <code>uint32 send_owner_interval = 2;</code>
         * @return The sendOwnerInterval.
         */
        @java.lang.Override
        public int getSendOwnerInterval() {
          return sendOwnerInterval_;
        }
        /**
         * <pre>
         * Send our owner info at least this often (also we always send once at boot - to rejoin the mesh)
         * </pre>
         *
         * <code>uint32 send_owner_interval = 2;</code>
         * @param value The sendOwnerInterval to set.
         * @return This builder for chaining.
         */
        public Builder setSendOwnerInterval(int value) {
          
          sendOwnerInterval_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Send our owner info at least this often (also we always send once at boot - to rejoin the mesh)
         * </pre>
         *
         * <code>uint32 send_owner_interval = 2;</code>
         * @return This builder for chaining.
         */
        public Builder clearSendOwnerInterval() {
          
          sendOwnerInterval_ = 0;
          onChanged();
          return this;
        }

        private int waitBluetoothSecs_ ;
        /**
         * <pre>
         * Power management state machine option.
         * See [power management](/software/other/power.md) for details.
         * 0 for default of 1 minute
         * </pre>
         *
         * <code>uint32 wait_bluetooth_secs = 4;</code>
         * @return The waitBluetoothSecs.
         */
        @java.lang.Override
        public int getWaitBluetoothSecs() {
          return waitBluetoothSecs_;
        }
        /**
         * <pre>
         * Power management state machine option.
         * See [power management](/software/other/power.md) for details.
         * 0 for default of 1 minute
         * </pre>
         *
         * <code>uint32 wait_bluetooth_secs = 4;</code>
         * @param value The waitBluetoothSecs to set.
         * @return This builder for chaining.
         */
        public Builder setWaitBluetoothSecs(int value) {
          
          waitBluetoothSecs_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Power management state machine option.
         * See [power management](/software/other/power.md) for details.
         * 0 for default of 1 minute
         * </pre>
         *
         * <code>uint32 wait_bluetooth_secs = 4;</code>
         * @return This builder for chaining.
         */
        public Builder clearWaitBluetoothSecs() {
          
          waitBluetoothSecs_ = 0;
          onChanged();
          return this;
        }

        private int screenOnSecs_ ;
        /**
         * <pre>
         * Power management state machine option.
         * See [power management](/software/other/power.md) for details.
         * 0 for default of one minute
         * </pre>
         *
         * <code>uint32 screen_on_secs = 5;</code>
         * @return The screenOnSecs.
         */
        @java.lang.Override
        public int getScreenOnSecs() {
          return screenOnSecs_;
        }
        /**
         * <pre>
         * Power management state machine option.
         * See [power management](/software/other/power.md) for details.
         * 0 for default of one minute
         * </pre>
         *
         * <code>uint32 screen_on_secs = 5;</code>
         * @param value The screenOnSecs to set.
         * @return This builder for chaining.
         */
        public Builder setScreenOnSecs(int value) {
          
          screenOnSecs_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Power management state machine option.
         * See [power management](/software/other/power.md) for details.
         * 0 for default of one minute
         * </pre>
         *
         * <code>uint32 screen_on_secs = 5;</code>
         * @return This builder for chaining.
         */
        public Builder clearScreenOnSecs() {
          
          screenOnSecs_ = 0;
          onChanged();
          return this;
        }

        private int phoneTimeoutSecs_ ;
        /**
         * <pre>
         * Power management state machine option.
         * See [power management](/software/other/power.md) for details.
         * 0 for default of 15 minutes
         * IMPORTANT NOTE FOR DEVICE CLIENTS: YOU MUST SEND SOME SORT OF PACKET TO THE PHONE AT LEAST THIS OFTEN OR THE DEVICE WILL DECIDE YOU ARE GONE!
         * </pre>
         *
         * <code>uint32 phone_timeout_secs = 6;</code>
         * @return The phoneTimeoutSecs.
         */
        @java.lang.Override
        public int getPhoneTimeoutSecs() {
          return phoneTimeoutSecs_;
        }
        /**
         * <pre>
         * Power management state machine option.
         * See [power management](/software/other/power.md) for details.
         * 0 for default of 15 minutes
         * IMPORTANT NOTE FOR DEVICE CLIENTS: YOU MUST SEND SOME SORT OF PACKET TO THE PHONE AT LEAST THIS OFTEN OR THE DEVICE WILL DECIDE YOU ARE GONE!
         * </pre>
         *
         * <code>uint32 phone_timeout_secs = 6;</code>
         * @param value The phoneTimeoutSecs to set.
         * @return This builder for chaining.
         */
        public Builder setPhoneTimeoutSecs(int value) {
          
          phoneTimeoutSecs_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Power management state machine option.
         * See [power management](/software/other/power.md) for details.
         * 0 for default of 15 minutes
         * IMPORTANT NOTE FOR DEVICE CLIENTS: YOU MUST SEND SOME SORT OF PACKET TO THE PHONE AT LEAST THIS OFTEN OR THE DEVICE WILL DECIDE YOU ARE GONE!
         * </pre>
         *
         * <code>uint32 phone_timeout_secs = 6;</code>
         * @return This builder for chaining.
         */
        public Builder clearPhoneTimeoutSecs() {
          
          phoneTimeoutSecs_ = 0;
          onChanged();
          return this;
        }

        private int phoneSdsTimeoutSec_ ;
        /**
         * <pre>
         * Power management state machine option.
         * See [power management](/software/other/power.md) for details.
         * 0 for default of two hours, MAXUINT for disabled
         * </pre>
         *
         * <code>uint32 phone_sds_timeout_sec = 7;</code>
         * @return The phoneSdsTimeoutSec.
         */
        @java.lang.Override
        public int getPhoneSdsTimeoutSec() {
          return phoneSdsTimeoutSec_;
        }
        /**
         * <pre>
         * Power management state machine option.
         * See [power management](/software/other/power.md) for details.
         * 0 for default of two hours, MAXUINT for disabled
         * </pre>
         *
         * <code>uint32 phone_sds_timeout_sec = 7;</code>
         * @param value The phoneSdsTimeoutSec to set.
         * @return This builder for chaining.
         */
        public Builder setPhoneSdsTimeoutSec(int value) {
          
          phoneSdsTimeoutSec_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Power management state machine option.
         * See [power management](/software/other/power.md) for details.
         * 0 for default of two hours, MAXUINT for disabled
         * </pre>
         *
         * <code>uint32 phone_sds_timeout_sec = 7;</code>
         * @return This builder for chaining.
         */
        public Builder clearPhoneSdsTimeoutSec() {
          
          phoneSdsTimeoutSec_ = 0;
          onChanged();
          return this;
        }

        private int meshSdsTimeoutSecs_ ;
        /**
         * <pre>
         * Power management state machine option.
         * See [power management](/software/other/power.md) for details.
         * 0 for default of two hours, MAXUINT for disabled
         * </pre>
         *
         * <code>uint32 mesh_sds_timeout_secs = 8;</code>
         * @return The meshSdsTimeoutSecs.
         */
        @java.lang.Override
        public int getMeshSdsTimeoutSecs() {
          return meshSdsTimeoutSecs_;
        }
        /**
         * <pre>
         * Power management state machine option.
         * See [power management](/software/other/power.md) for details.
         * 0 for default of two hours, MAXUINT for disabled
         * </pre>
         *
         * <code>uint32 mesh_sds_timeout_secs = 8;</code>
         * @param value The meshSdsTimeoutSecs to set.
         * @return This builder for chaining.
         */
        public Builder setMeshSdsTimeoutSecs(int value) {
          
          meshSdsTimeoutSecs_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Power management state machine option.
         * See [power management](/software/other/power.md) for details.
         * 0 for default of two hours, MAXUINT for disabled
         * </pre>
         *
         * <code>uint32 mesh_sds_timeout_secs = 8;</code>
         * @return This builder for chaining.
         */
        public Builder clearMeshSdsTimeoutSecs() {
          
          meshSdsTimeoutSecs_ = 0;
          onChanged();
          return this;
        }

        private int sdsSecs_ ;
        /**
         * <pre>
         * Power management state machine option.
         * See [power management](/software/other/power.md) for details.
         * 0 for default of one year
         * </pre>
         *
         * <code>uint32 sds_secs = 9;</code>
         * @return The sdsSecs.
         */
        @java.lang.Override
        public int getSdsSecs() {
          return sdsSecs_;
        }
        /**
         * <pre>
         * Power management state machine option.
         * See [power management](/software/other/power.md) for details.
         * 0 for default of one year
         * </pre>
         *
         * <code>uint32 sds_secs = 9;</code>
         * @param value The sdsSecs to set.
         * @return This builder for chaining.
         */
        public Builder setSdsSecs(int value) {
          
          sdsSecs_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Power management state machine option.
         * See [power management](/software/other/power.md) for details.
         * 0 for default of one year
         * </pre>
         *
         * <code>uint32 sds_secs = 9;</code>
         * @return This builder for chaining.
         */
        public Builder clearSdsSecs() {
          
          sdsSecs_ = 0;
          onChanged();
          return this;
        }

        private int lsSecs_ ;
        /**
         * <pre>
         * Power management state machine option.
         * See [power management](/software/other/power.md) for details.
         * 0 for default of 3600
         * </pre>
         *
         * <code>uint32 ls_secs = 10;</code>
         * @return The lsSecs.
         */
        @java.lang.Override
        public int getLsSecs() {
          return lsSecs_;
        }
        /**
         * <pre>
         * Power management state machine option.
         * See [power management](/software/other/power.md) for details.
         * 0 for default of 3600
         * </pre>
         *
         * <code>uint32 ls_secs = 10;</code>
         * @param value The lsSecs to set.
         * @return This builder for chaining.
         */
        public Builder setLsSecs(int value) {
          
          lsSecs_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Power management state machine option.
         * See [power management](/software/other/power.md) for details.
         * 0 for default of 3600
         * </pre>
         *
         * <code>uint32 ls_secs = 10;</code>
         * @return This builder for chaining.
         */
        public Builder clearLsSecs() {
          
          lsSecs_ = 0;
          onChanged();
          return this;
        }

        private int minWakeSecs_ ;
        /**
         * <pre>
         * Power management state machine option.
         * See [power management](/software/other/power.md) for details.
         * 0 for default of 10 seconds
         * </pre>
         *
         * <code>uint32 min_wake_secs = 11;</code>
         * @return The minWakeSecs.
         */
        @java.lang.Override
        public int getMinWakeSecs() {
          return minWakeSecs_;
        }
        /**
         * <pre>
         * Power management state machine option.
         * See [power management](/software/other/power.md) for details.
         * 0 for default of 10 seconds
         * </pre>
         *
         * <code>uint32 min_wake_secs = 11;</code>
         * @param value The minWakeSecs to set.
         * @return This builder for chaining.
         */
        public Builder setMinWakeSecs(int value) {
          
          minWakeSecs_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Power management state machine option.
         * See [power management](/software/other/power.md) for details.
         * 0 for default of 10 seconds
         * </pre>
         *
         * <code>uint32 min_wake_secs = 11;</code>
         * @return This builder for chaining.
         */
        public Builder clearMinWakeSecs() {
          
          minWakeSecs_ = 0;
          onChanged();
          return this;
        }

        private java.lang.Object wifiSsid_ = "";
        /**
         * <pre>
         * If set, this node will try to join the specified wifi network and
         * acquire an address via DHCP
         * </pre>
         *
         * <code>string wifi_ssid = 12;</code>
         * @return The wifiSsid.
         */
        public java.lang.String getWifiSsid() {
          java.lang.Object ref = wifiSsid_;
          if (!(ref instanceof java.lang.String)) {
            com.google.protobuf.ByteString bs =
                (com.google.protobuf.ByteString) ref;
            java.lang.String s = bs.toStringUtf8();
            wifiSsid_ = s;
            return s;
          } else {
            return (java.lang.String) ref;
          }
        }
        /**
         * <pre>
         * If set, this node will try to join the specified wifi network and
         * acquire an address via DHCP
         * </pre>
         *
         * <code>string wifi_ssid = 12;</code>
         * @return The bytes for wifiSsid.
         */
        public com.google.protobuf.ByteString
            getWifiSsidBytes() {
          java.lang.Object ref = wifiSsid_;
          if (ref instanceof String) {
            com.google.protobuf.ByteString b = 
                com.google.protobuf.ByteString.copyFromUtf8(
                    (java.lang.String) ref);
            wifiSsid_ = b;
            return b;
          } else {
            return (com.google.protobuf.ByteString) ref;
          }
        }
        /**
         * <pre>
         * If set, this node will try to join the specified wifi network and
         * acquire an address via DHCP
         * </pre>
         *
         * <code>string wifi_ssid = 12;</code>
         * @param value The wifiSsid to set.
         * @return This builder for chaining.
         */
        public Builder setWifiSsid(
            java.lang.String value) {
          if (value == null) {
    throw new NullPointerException();
  }
  
          wifiSsid_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * If set, this node will try to join the specified wifi network and
         * acquire an address via DHCP
         * </pre>
         *
         * <code>string wifi_ssid = 12;</code>
         * @return This builder for chaining.
         */
        public Builder clearWifiSsid() {
          
          wifiSsid_ = getDefaultInstance().getWifiSsid();
          onChanged();
          return this;
        }
        /**
         * <pre>
         * If set, this node will try to join the specified wifi network and
         * acquire an address via DHCP
         * </pre>
         *
         * <code>string wifi_ssid = 12;</code>
         * @param value The bytes for wifiSsid to set.
         * @return This builder for chaining.
         */
        public Builder setWifiSsidBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
          
          wifiSsid_ = value;
          onChanged();
          return this;
        }

        private java.lang.Object wifiPassword_ = "";
        /**
         * <pre>
         * If set, will be use to authenticate to the named wifi
         * </pre>
         *
         * <code>string wifi_password = 13;</code>
         * @return The wifiPassword.
         */
        public java.lang.String getWifiPassword() {
          java.lang.Object ref = wifiPassword_;
          if (!(ref instanceof java.lang.String)) {
            com.google.protobuf.ByteString bs =
                (com.google.protobuf.ByteString) ref;
            java.lang.String s = bs.toStringUtf8();
            wifiPassword_ = s;
            return s;
          } else {
            return (java.lang.String) ref;
          }
        }
        /**
         * <pre>
         * If set, will be use to authenticate to the named wifi
         * </pre>
         *
         * <code>string wifi_password = 13;</code>
         * @return The bytes for wifiPassword.
         */
        public com.google.protobuf.ByteString
            getWifiPasswordBytes() {
          java.lang.Object ref = wifiPassword_;
          if (ref instanceof String) {
            com.google.protobuf.ByteString b = 
                com.google.protobuf.ByteString.copyFromUtf8(
                    (java.lang.String) ref);
            wifiPassword_ = b;
            return b;
          } else {
            return (com.google.protobuf.ByteString) ref;
          }
        }
        /**
         * <pre>
         * If set, will be use to authenticate to the named wifi
         * </pre>
         *
         * <code>string wifi_password = 13;</code>
         * @param value The wifiPassword to set.
         * @return This builder for chaining.
         */
        public Builder setWifiPassword(
            java.lang.String value) {
          if (value == null) {
    throw new NullPointerException();
  }
  
          wifiPassword_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * If set, will be use to authenticate to the named wifi
         * </pre>
         *
         * <code>string wifi_password = 13;</code>
         * @return This builder for chaining.
         */
        public Builder clearWifiPassword() {
          
          wifiPassword_ = getDefaultInstance().getWifiPassword();
          onChanged();
          return this;
        }
        /**
         * <pre>
         * If set, will be use to authenticate to the named wifi
         * </pre>
         *
         * <code>string wifi_password = 13;</code>
         * @param value The bytes for wifiPassword to set.
         * @return This builder for chaining.
         */
        public Builder setWifiPasswordBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
          
          wifiPassword_ = value;
          onChanged();
          return this;
        }

        private boolean wifiApMode_ ;
        /**
         * <pre>
         * If set, the node will operate as an AP (and DHCP server), otherwise it
         * will be a station
         * </pre>
         *
         * <code>bool wifi_ap_mode = 14;</code>
         * @return The wifiApMode.
         */
        @java.lang.Override
        public boolean getWifiApMode() {
          return wifiApMode_;
        }
        /**
         * <pre>
         * If set, the node will operate as an AP (and DHCP server), otherwise it
         * will be a station
         * </pre>
         *
         * <code>bool wifi_ap_mode = 14;</code>
         * @param value The wifiApMode to set.
         * @return This builder for chaining.
         */
        public Builder setWifiApMode(boolean value) {
          
          wifiApMode_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * If set, the node will operate as an AP (and DHCP server), otherwise it
         * will be a station
         * </pre>
         *
         * <code>bool wifi_ap_mode = 14;</code>
         * @return This builder for chaining.
         */
        public Builder clearWifiApMode() {
          
          wifiApMode_ = false;
          onChanged();
          return this;
        }

        private int region_ = 0;
        /**
         * <pre>
         * The region code for my radio (US, CN, EU433, etc...)
         * </pre>
         *
         * <code>.RegionCode region = 15;</code>
         * @return The enum numeric value on the wire for region.
         */
        @java.lang.Override public int getRegionValue() {
          return region_;
        }
        /**
         * <pre>
         * The region code for my radio (US, CN, EU433, etc...)
         * </pre>
         *
         * <code>.RegionCode region = 15;</code>
         * @param value The enum numeric value on the wire for region to set.
         * @return This builder for chaining.
         */
        public Builder setRegionValue(int value) {
          
          region_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The region code for my radio (US, CN, EU433, etc...)
         * </pre>
         *
         * <code>.RegionCode region = 15;</code>
         * @return The region.
         */
        @java.lang.Override
        public com.geeksville.mesh.RadioConfigProtos.RegionCode getRegion() {
          @SuppressWarnings("deprecation")
          com.geeksville.mesh.RadioConfigProtos.RegionCode result = com.geeksville.mesh.RadioConfigProtos.RegionCode.valueOf(region_);
          return result == null ? com.geeksville.mesh.RadioConfigProtos.RegionCode.UNRECOGNIZED : result;
        }
        /**
         * <pre>
         * The region code for my radio (US, CN, EU433, etc...)
         * </pre>
         *
         * <code>.RegionCode region = 15;</code>
         * @param value The region to set.
         * @return This builder for chaining.
         */
        public Builder setRegion(com.geeksville.mesh.RadioConfigProtos.RegionCode value) {
          if (value == null) {
            throw new NullPointerException();
          }
          
          region_ = value.getNumber();
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The region code for my radio (US, CN, EU433, etc...)
         * </pre>
         *
         * <code>.RegionCode region = 15;</code>
         * @return This builder for chaining.
         */
        public Builder clearRegion() {
          
          region_ = 0;
          onChanged();
          return this;
        }

        private int chargeCurrent_ = 0;
        /**
         * <pre>
         * Sets the current of the battery charger
         * </pre>
         *
         * <code>.ChargeCurrent charge_current = 16;</code>
         * @return The enum numeric value on the wire for chargeCurrent.
         */
        @java.lang.Override public int getChargeCurrentValue() {
          return chargeCurrent_;
        }
        /**
         * <pre>
         * Sets the current of the battery charger
         * </pre>
         *
         * <code>.ChargeCurrent charge_current = 16;</code>
         * @param value The enum numeric value on the wire for chargeCurrent to set.
         * @return This builder for chaining.
         */
        public Builder setChargeCurrentValue(int value) {
          
          chargeCurrent_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Sets the current of the battery charger
         * </pre>
         *
         * <code>.ChargeCurrent charge_current = 16;</code>
         * @return The chargeCurrent.
         */
        @java.lang.Override
        public com.geeksville.mesh.RadioConfigProtos.ChargeCurrent getChargeCurrent() {
          @SuppressWarnings("deprecation")
          com.geeksville.mesh.RadioConfigProtos.ChargeCurrent result = com.geeksville.mesh.RadioConfigProtos.ChargeCurrent.valueOf(chargeCurrent_);
          return result == null ? com.geeksville.mesh.RadioConfigProtos.ChargeCurrent.UNRECOGNIZED : result;
        }
        /**
         * <pre>
         * Sets the current of the battery charger
         * </pre>
         *
         * <code>.ChargeCurrent charge_current = 16;</code>
         * @param value The chargeCurrent to set.
         * @return This builder for chaining.
         */
        public Builder setChargeCurrent(com.geeksville.mesh.RadioConfigProtos.ChargeCurrent value) {
          if (value == null) {
            throw new NullPointerException();
          }
          
          chargeCurrent_ = value.getNumber();
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Sets the current of the battery charger
         * </pre>
         *
         * <code>.ChargeCurrent charge_current = 16;</code>
         * @return This builder for chaining.
         */
        public Builder clearChargeCurrent() {
          
          chargeCurrent_ = 0;
          onChanged();
          return this;
        }

        private boolean isRouter_ ;
        /**
         * <pre>
         * Are we operating as a router.
         * Changes behavior in the following ways:
         * The device will only sleep for critically low battery level (i.e. always tries to stay alive for the mesh)
         * In the future routing decisions will preferentially route packets through nodes with this attribute (because assumed
         * good line of sight)
         * </pre>
         *
         * <code>bool is_router = 37;</code>
         * @return The isRouter.
         */
        @java.lang.Override
        public boolean getIsRouter() {
          return isRouter_;
        }
        /**
         * <pre>
         * Are we operating as a router.
         * Changes behavior in the following ways:
         * The device will only sleep for critically low battery level (i.e. always tries to stay alive for the mesh)
         * In the future routing decisions will preferentially route packets through nodes with this attribute (because assumed
         * good line of sight)
         * </pre>
         *
         * <code>bool is_router = 37;</code>
         * @param value The isRouter to set.
         * @return This builder for chaining.
         */
        public Builder setIsRouter(boolean value) {
          
          isRouter_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Are we operating as a router.
         * Changes behavior in the following ways:
         * The device will only sleep for critically low battery level (i.e. always tries to stay alive for the mesh)
         * In the future routing decisions will preferentially route packets through nodes with this attribute (because assumed
         * good line of sight)
         * </pre>
         *
         * <code>bool is_router = 37;</code>
         * @return This builder for chaining.
         */
        public Builder clearIsRouter() {
          
          isRouter_ = false;
          onChanged();
          return this;
        }

        private boolean isLowPower_ ;
        /**
         * <pre>
         * If set, we are powered from a low-current source (i.e. solar), so even if it looks like we have power flowing in
         * we should try to minimize power consumption as much as possible.
         * YOU DO NOT NEED TO SET THIS IF YOU'VE set is_router (it is implied in that case).
         * </pre>
         *
         * <code>bool is_low_power = 38;</code>
         * @return The isLowPower.
         */
        @java.lang.Override
        public boolean getIsLowPower() {
          return isLowPower_;
        }
        /**
         * <pre>
         * If set, we are powered from a low-current source (i.e. solar), so even if it looks like we have power flowing in
         * we should try to minimize power consumption as much as possible.
         * YOU DO NOT NEED TO SET THIS IF YOU'VE set is_router (it is implied in that case).
         * </pre>
         *
         * <code>bool is_low_power = 38;</code>
         * @param value The isLowPower to set.
         * @return This builder for chaining.
         */
        public Builder setIsLowPower(boolean value) {
          
          isLowPower_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * If set, we are powered from a low-current source (i.e. solar), so even if it looks like we have power flowing in
         * we should try to minimize power consumption as much as possible.
         * YOU DO NOT NEED TO SET THIS IF YOU'VE set is_router (it is implied in that case).
         * </pre>
         *
         * <code>bool is_low_power = 38;</code>
         * @return This builder for chaining.
         */
        public Builder clearIsLowPower() {
          
          isLowPower_ = false;
          onChanged();
          return this;
        }

        private boolean fixedPosition_ ;
        /**
         * <pre>
         * If set, this node is at a fixed position.
         * We will generate GPS position updates at the regular interval, but use whatever the last lat/lon/alt we have for the node.
         * The lat/lon/alt can be set by an internal GPS or with the help of the app.
         * </pre>
         *
         * <code>bool fixed_position = 39;</code>
         * @return The fixedPosition.
         */
        @java.lang.Override
        public boolean getFixedPosition() {
          return fixedPosition_;
        }
        /**
         * <pre>
         * If set, this node is at a fixed position.
         * We will generate GPS position updates at the regular interval, but use whatever the last lat/lon/alt we have for the node.
         * The lat/lon/alt can be set by an internal GPS or with the help of the app.
         * </pre>
         *
         * <code>bool fixed_position = 39;</code>
         * @param value The fixedPosition to set.
         * @return This builder for chaining.
         */
        public Builder setFixedPosition(boolean value) {
          
          fixedPosition_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * If set, this node is at a fixed position.
         * We will generate GPS position updates at the regular interval, but use whatever the last lat/lon/alt we have for the node.
         * The lat/lon/alt can be set by an internal GPS or with the help of the app.
         * </pre>
         *
         * <code>bool fixed_position = 39;</code>
         * @return This builder for chaining.
         */
        public Builder clearFixedPosition() {
          
          fixedPosition_ = false;
          onChanged();
          return this;
        }

        private boolean serialDisabled_ ;
        /**
         * <pre>
         * If set, this will disable the SerialConsole by not initilizing the StreamAPI
         * </pre>
         *
         * <code>bool serial_disabled = 40;</code>
         * @return The serialDisabled.
         */
        @java.lang.Override
        public boolean getSerialDisabled() {
          return serialDisabled_;
        }
        /**
         * <pre>
         * If set, this will disable the SerialConsole by not initilizing the StreamAPI
         * </pre>
         *
         * <code>bool serial_disabled = 40;</code>
         * @param value The serialDisabled to set.
         * @return This builder for chaining.
         */
        public Builder setSerialDisabled(boolean value) {
          
          serialDisabled_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * If set, this will disable the SerialConsole by not initilizing the StreamAPI
         * </pre>
         *
         * <code>bool serial_disabled = 40;</code>
         * @return This builder for chaining.
         */
        public Builder clearSerialDisabled() {
          
          serialDisabled_ = false;
          onChanged();
          return this;
        }

        private int locationShare_ = 0;
        /**
         * <pre>
         * How our location is shared with other nodes (or the local phone)
         * </pre>
         *
         * <code>.LocationSharing location_share = 32;</code>
         * @return The enum numeric value on the wire for locationShare.
         */
        @java.lang.Override public int getLocationShareValue() {
          return locationShare_;
        }
        /**
         * <pre>
         * How our location is shared with other nodes (or the local phone)
         * </pre>
         *
         * <code>.LocationSharing location_share = 32;</code>
         * @param value The enum numeric value on the wire for locationShare to set.
         * @return This builder for chaining.
         */
        public Builder setLocationShareValue(int value) {
          
          locationShare_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * How our location is shared with other nodes (or the local phone)
         * </pre>
         *
         * <code>.LocationSharing location_share = 32;</code>
         * @return The locationShare.
         */
        @java.lang.Override
        public com.geeksville.mesh.RadioConfigProtos.LocationSharing getLocationShare() {
          @SuppressWarnings("deprecation")
          com.geeksville.mesh.RadioConfigProtos.LocationSharing result = com.geeksville.mesh.RadioConfigProtos.LocationSharing.valueOf(locationShare_);
          return result == null ? com.geeksville.mesh.RadioConfigProtos.LocationSharing.UNRECOGNIZED : result;
        }
        /**
         * <pre>
         * How our location is shared with other nodes (or the local phone)
         * </pre>
         *
         * <code>.LocationSharing location_share = 32;</code>
         * @param value The locationShare to set.
         * @return This builder for chaining.
         */
        public Builder setLocationShare(com.geeksville.mesh.RadioConfigProtos.LocationSharing value) {
          if (value == null) {
            throw new NullPointerException();
          }
          
          locationShare_ = value.getNumber();
          onChanged();
          return this;
        }
        /**
         * <pre>
         * How our location is shared with other nodes (or the local phone)
         * </pre>
         *
         * <code>.LocationSharing location_share = 32;</code>
         * @return This builder for chaining.
         */
        public Builder clearLocationShare() {
          
          locationShare_ = 0;
          onChanged();
          return this;
        }

        private int gpsOperation_ = 0;
        /**
         * <pre>
         * How the GPS hardware in this unit is operated.
         * Note: This is independent of how our location is shared with other devices.
         * For that see LocationSharing
         * </pre>
         *
         * <code>.GpsOperation gps_operation = 33;</code>
         * @return The enum numeric value on the wire for gpsOperation.
         */
        @java.lang.Override public int getGpsOperationValue() {
          return gpsOperation_;
        }
        /**
         * <pre>
         * How the GPS hardware in this unit is operated.
         * Note: This is independent of how our location is shared with other devices.
         * For that see LocationSharing
         * </pre>
         *
         * <code>.GpsOperation gps_operation = 33;</code>
         * @param value The enum numeric value on the wire for gpsOperation to set.
         * @return This builder for chaining.
         */
        public Builder setGpsOperationValue(int value) {
          
          gpsOperation_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * How the GPS hardware in this unit is operated.
         * Note: This is independent of how our location is shared with other devices.
         * For that see LocationSharing
         * </pre>
         *
         * <code>.GpsOperation gps_operation = 33;</code>
         * @return The gpsOperation.
         */
        @java.lang.Override
        public com.geeksville.mesh.RadioConfigProtos.GpsOperation getGpsOperation() {
          @SuppressWarnings("deprecation")
          com.geeksville.mesh.RadioConfigProtos.GpsOperation result = com.geeksville.mesh.RadioConfigProtos.GpsOperation.valueOf(gpsOperation_);
          return result == null ? com.geeksville.mesh.RadioConfigProtos.GpsOperation.UNRECOGNIZED : result;
        }
        /**
         * <pre>
         * How the GPS hardware in this unit is operated.
         * Note: This is independent of how our location is shared with other devices.
         * For that see LocationSharing
         * </pre>
         *
         * <code>.GpsOperation gps_operation = 33;</code>
         * @param value The gpsOperation to set.
         * @return This builder for chaining.
         */
        public Builder setGpsOperation(com.geeksville.mesh.RadioConfigProtos.GpsOperation value) {
          if (value == null) {
            throw new NullPointerException();
          }
          
          gpsOperation_ = value.getNumber();
          onChanged();
          return this;
        }
        /**
         * <pre>
         * How the GPS hardware in this unit is operated.
         * Note: This is independent of how our location is shared with other devices.
         * For that see LocationSharing
         * </pre>
         *
         * <code>.GpsOperation gps_operation = 33;</code>
         * @return This builder for chaining.
         */
        public Builder clearGpsOperation() {
          
          gpsOperation_ = 0;
          onChanged();
          return this;
        }

        private int gpsUpdateInterval_ ;
        /**
         * <pre>
         * How often should we try to get GPS position (in seconds) when we are in GpsOpMobile mode?
         * or zero for the default of once every 30 seconds
         * or a very large value (maxint) to update only once at boot.
         * </pre>
         *
         * <code>uint32 gps_update_interval = 34;</code>
         * @return The gpsUpdateInterval.
         */
        @java.lang.Override
        public int getGpsUpdateInterval() {
          return gpsUpdateInterval_;
        }
        /**
         * <pre>
         * How often should we try to get GPS position (in seconds) when we are in GpsOpMobile mode?
         * or zero for the default of once every 30 seconds
         * or a very large value (maxint) to update only once at boot.
         * </pre>
         *
         * <code>uint32 gps_update_interval = 34;</code>
         * @param value The gpsUpdateInterval to set.
         * @return This builder for chaining.
         */
        public Builder setGpsUpdateInterval(int value) {
          
          gpsUpdateInterval_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * How often should we try to get GPS position (in seconds) when we are in GpsOpMobile mode?
         * or zero for the default of once every 30 seconds
         * or a very large value (maxint) to update only once at boot.
         * </pre>
         *
         * <code>uint32 gps_update_interval = 34;</code>
         * @return This builder for chaining.
         */
        public Builder clearGpsUpdateInterval() {
          
          gpsUpdateInterval_ = 0;
          onChanged();
          return this;
        }

        private int gpsAttemptTime_ ;
        /**
         * <pre>
         * How long should we try to get our position during each gps_update_interval attempt?  (in seconds)
         * Or if zero, use the default of 30 seconds.
         * If we don't get a new gps fix in that time, the gps will be put into sleep until  the next gps_update_rate
         * window. 
         * </pre>
         *
         * <code>uint32 gps_attempt_time = 36;</code>
         * @return The gpsAttemptTime.
         */
        @java.lang.Override
        public int getGpsAttemptTime() {
          return gpsAttemptTime_;
        }
        /**
         * <pre>
         * How long should we try to get our position during each gps_update_interval attempt?  (in seconds)
         * Or if zero, use the default of 30 seconds.
         * If we don't get a new gps fix in that time, the gps will be put into sleep until  the next gps_update_rate
         * window. 
         * </pre>
         *
         * <code>uint32 gps_attempt_time = 36;</code>
         * @param value The gpsAttemptTime to set.
         * @return This builder for chaining.
         */
        public Builder setGpsAttemptTime(int value) {
          
          gpsAttemptTime_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * How long should we try to get our position during each gps_update_interval attempt?  (in seconds)
         * Or if zero, use the default of 30 seconds.
         * If we don't get a new gps fix in that time, the gps will be put into sleep until  the next gps_update_rate
         * window. 
         * </pre>
         *
         * <code>uint32 gps_attempt_time = 36;</code>
         * @return This builder for chaining.
         */
        public Builder clearGpsAttemptTime() {
          
          gpsAttemptTime_ = 0;
          onChanged();
          return this;
        }

        private float frequencyOffset_ ;
        /**
         * <pre>
         * This parameter is for advanced users with advanced test equipment, we do not recommend most users use it.
         * A frequency offset that is added to to the calculated band center frequency.
         * Used to correct for crystal calibration errors.
         * </pre>
         *
         * <code>float frequency_offset = 41;</code>
         * @return The frequencyOffset.
         */
        @java.lang.Override
        public float getFrequencyOffset() {
          return frequencyOffset_;
        }
        /**
         * <pre>
         * This parameter is for advanced users with advanced test equipment, we do not recommend most users use it.
         * A frequency offset that is added to to the calculated band center frequency.
         * Used to correct for crystal calibration errors.
         * </pre>
         *
         * <code>float frequency_offset = 41;</code>
         * @param value The frequencyOffset to set.
         * @return This builder for chaining.
         */
        public Builder setFrequencyOffset(float value) {
          
          frequencyOffset_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * This parameter is for advanced users with advanced test equipment, we do not recommend most users use it.
         * A frequency offset that is added to to the calculated band center frequency.
         * Used to correct for crystal calibration errors.
         * </pre>
         *
         * <code>float frequency_offset = 41;</code>
         * @return This builder for chaining.
         */
        public Builder clearFrequencyOffset() {
          
          frequencyOffset_ = 0F;
          onChanged();
          return this;
        }

        private java.lang.Object mqttServer_ = "";
        /**
         * <pre>
         * The server to use for our MQTT global message gateway feature.
         * If not set, the default server will be used 
         * </pre>
         *
         * <code>string mqtt_server = 42;</code>
         * @return The mqttServer.
         */
        public java.lang.String getMqttServer() {
          java.lang.Object ref = mqttServer_;
          if (!(ref instanceof java.lang.String)) {
            com.google.protobuf.ByteString bs =
                (com.google.protobuf.ByteString) ref;
            java.lang.String s = bs.toStringUtf8();
            mqttServer_ = s;
            return s;
          } else {
            return (java.lang.String) ref;
          }
        }
        /**
         * <pre>
         * The server to use for our MQTT global message gateway feature.
         * If not set, the default server will be used 
         * </pre>
         *
         * <code>string mqtt_server = 42;</code>
         * @return The bytes for mqttServer.
         */
        public com.google.protobuf.ByteString
            getMqttServerBytes() {
          java.lang.Object ref = mqttServer_;
          if (ref instanceof String) {
            com.google.protobuf.ByteString b = 
                com.google.protobuf.ByteString.copyFromUtf8(
                    (java.lang.String) ref);
            mqttServer_ = b;
            return b;
          } else {
            return (com.google.protobuf.ByteString) ref;
          }
        }
        /**
         * <pre>
         * The server to use for our MQTT global message gateway feature.
         * If not set, the default server will be used 
         * </pre>
         *
         * <code>string mqtt_server = 42;</code>
         * @param value The mqttServer to set.
         * @return This builder for chaining.
         */
        public Builder setMqttServer(
            java.lang.String value) {
          if (value == null) {
    throw new NullPointerException();
  }
  
          mqttServer_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The server to use for our MQTT global message gateway feature.
         * If not set, the default server will be used 
         * </pre>
         *
         * <code>string mqtt_server = 42;</code>
         * @return This builder for chaining.
         */
        public Builder clearMqttServer() {
          
          mqttServer_ = getDefaultInstance().getMqttServer();
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The server to use for our MQTT global message gateway feature.
         * If not set, the default server will be used 
         * </pre>
         *
         * <code>string mqtt_server = 42;</code>
         * @param value The bytes for mqttServer to set.
         * @return This builder for chaining.
         */
        public Builder setMqttServerBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
          
          mqttServer_ = value;
          onChanged();
          return this;
        }

        private boolean mqttDisabled_ ;
        /**
         * <pre>
         * If a meshtastic node is able to reach the internet it will normally attempt to gateway any channels that are marked as
         * is_uplink_enabled or is_downlink_enabled.
         * But if this flag is set, all MQTT features will be disabled and no servers will be contacted.
         * </pre>
         *
         * <code>bool mqtt_disabled = 43;</code>
         * @return The mqttDisabled.
         */
        @java.lang.Override
        public boolean getMqttDisabled() {
          return mqttDisabled_;
        }
        /**
         * <pre>
         * If a meshtastic node is able to reach the internet it will normally attempt to gateway any channels that are marked as
         * is_uplink_enabled or is_downlink_enabled.
         * But if this flag is set, all MQTT features will be disabled and no servers will be contacted.
         * </pre>
         *
         * <code>bool mqtt_disabled = 43;</code>
         * @param value The mqttDisabled to set.
         * @return This builder for chaining.
         */
        public Builder setMqttDisabled(boolean value) {
          
          mqttDisabled_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * If a meshtastic node is able to reach the internet it will normally attempt to gateway any channels that are marked as
         * is_uplink_enabled or is_downlink_enabled.
         * But if this flag is set, all MQTT features will be disabled and no servers will be contacted.
         * </pre>
         *
         * <code>bool mqtt_disabled = 43;</code>
         * @return This builder for chaining.
         */
        public Builder clearMqttDisabled() {
          
          mqttDisabled_ = false;
          onChanged();
          return this;
        }

        private boolean factoryReset_ ;
        /**
         * <pre>
         * This setting is never saved to disk, but if set, all device settings will be returned to factory defaults.
         * (Region, serial number etc... will be preserved)
         * </pre>
         *
         * <code>bool factory_reset = 100;</code>
         * @return The factoryReset.
         */
        @java.lang.Override
        public boolean getFactoryReset() {
          return factoryReset_;
        }
        /**
         * <pre>
         * This setting is never saved to disk, but if set, all device settings will be returned to factory defaults.
         * (Region, serial number etc... will be preserved)
         * </pre>
         *
         * <code>bool factory_reset = 100;</code>
         * @param value The factoryReset to set.
         * @return This builder for chaining.
         */
        public Builder setFactoryReset(boolean value) {
          
          factoryReset_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * This setting is never saved to disk, but if set, all device settings will be returned to factory defaults.
         * (Region, serial number etc... will be preserved)
         * </pre>
         *
         * <code>bool factory_reset = 100;</code>
         * @return This builder for chaining.
         */
        public Builder clearFactoryReset() {
          
          factoryReset_ = false;
          onChanged();
          return this;
        }

        private boolean debugLogEnabled_ ;
        /**
         * <pre>
         * By default we turn off logging as soon as an API client connects (to keep shared serial link quiet).
         * Set this to true to leave the debug log outputting even when API is active.
         * </pre>
         *
         * <code>bool debug_log_enabled = 101;</code>
         * @return The debugLogEnabled.
         */
        @java.lang.Override
        public boolean getDebugLogEnabled() {
          return debugLogEnabled_;
        }
        /**
         * <pre>
         * By default we turn off logging as soon as an API client connects (to keep shared serial link quiet).
         * Set this to true to leave the debug log outputting even when API is active.
         * </pre>
         *
         * <code>bool debug_log_enabled = 101;</code>
         * @param value The debugLogEnabled to set.
         * @return This builder for chaining.
         */
        public Builder setDebugLogEnabled(boolean value) {
          
          debugLogEnabled_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * By default we turn off logging as soon as an API client connects (to keep shared serial link quiet).
         * Set this to true to leave the debug log outputting even when API is active.
         * </pre>
         *
         * <code>bool debug_log_enabled = 101;</code>
         * @return This builder for chaining.
         */
        public Builder clearDebugLogEnabled() {
          
          debugLogEnabled_ = false;
          onChanged();
          return this;
        }

        private com.google.protobuf.Internal.IntList ignoreIncoming_ = emptyIntList();
        private void ensureIgnoreIncomingIsMutable() {
          if (!((bitField0_ & 0x00000001) != 0)) {
            ignoreIncoming_ = mutableCopy(ignoreIncoming_);
            bitField0_ |= 0x00000001;
           }
        }
        /**
         * <pre>
         * If true, radio should not try to be smart about what packets to queue to
         * the phone
         * bool keep_all_packets = 101;
         * If true, we will try to capture all the packets sent on the mesh, not just the ones destined to our node.
         * bool promiscuous_mode = 102;
         * For testing it is useful sometimes to force a node to never listen to
         * particular other nodes (simulating radio out of range). All nodenums listed
         * in ignore_incoming will have packets they send droped on receive (by router.cpp)
         * </pre>
         *
         * <code>repeated uint32 ignore_incoming = 103;</code>
         * @return A list containing the ignoreIncoming.
         */
        public java.util.List<java.lang.Integer>
            getIgnoreIncomingList() {
          return ((bitField0_ & 0x00000001) != 0) ?
                   java.util.Collections.unmodifiableList(ignoreIncoming_) : ignoreIncoming_;
        }
        /**
         * <pre>
         * If true, radio should not try to be smart about what packets to queue to
         * the phone
         * bool keep_all_packets = 101;
         * If true, we will try to capture all the packets sent on the mesh, not just the ones destined to our node.
         * bool promiscuous_mode = 102;
         * For testing it is useful sometimes to force a node to never listen to
         * particular other nodes (simulating radio out of range). All nodenums listed
         * in ignore_incoming will have packets they send droped on receive (by router.cpp)
         * </pre>
         *
         * <code>repeated uint32 ignore_incoming = 103;</code>
         * @return The count of ignoreIncoming.
         */
        public int getIgnoreIncomingCount() {
          return ignoreIncoming_.size();
        }
        /**
         * <pre>
         * If true, radio should not try to be smart about what packets to queue to
         * the phone
         * bool keep_all_packets = 101;
         * If true, we will try to capture all the packets sent on the mesh, not just the ones destined to our node.
         * bool promiscuous_mode = 102;
         * For testing it is useful sometimes to force a node to never listen to
         * particular other nodes (simulating radio out of range). All nodenums listed
         * in ignore_incoming will have packets they send droped on receive (by router.cpp)
         * </pre>
         *
         * <code>repeated uint32 ignore_incoming = 103;</code>
         * @param index The index of the element to return.
         * @return The ignoreIncoming at the given index.
         */
        public int getIgnoreIncoming(int index) {
          return ignoreIncoming_.getInt(index);
        }
        /**
         * <pre>
         * If true, radio should not try to be smart about what packets to queue to
         * the phone
         * bool keep_all_packets = 101;
         * If true, we will try to capture all the packets sent on the mesh, not just the ones destined to our node.
         * bool promiscuous_mode = 102;
         * For testing it is useful sometimes to force a node to never listen to
         * particular other nodes (simulating radio out of range). All nodenums listed
         * in ignore_incoming will have packets they send droped on receive (by router.cpp)
         * </pre>
         *
         * <code>repeated uint32 ignore_incoming = 103;</code>
         * @param index The index to set the value at.
         * @param value The ignoreIncoming to set.
         * @return This builder for chaining.
         */
        public Builder setIgnoreIncoming(
            int index, int value) {
          ensureIgnoreIncomingIsMutable();
          ignoreIncoming_.setInt(index, value);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * If true, radio should not try to be smart about what packets to queue to
         * the phone
         * bool keep_all_packets = 101;
         * If true, we will try to capture all the packets sent on the mesh, not just the ones destined to our node.
         * bool promiscuous_mode = 102;
         * For testing it is useful sometimes to force a node to never listen to
         * particular other nodes (simulating radio out of range). All nodenums listed
         * in ignore_incoming will have packets they send droped on receive (by router.cpp)
         * </pre>
         *
         * <code>repeated uint32 ignore_incoming = 103;</code>
         * @param value The ignoreIncoming to add.
         * @return This builder for chaining.
         */
        public Builder addIgnoreIncoming(int value) {
          ensureIgnoreIncomingIsMutable();
          ignoreIncoming_.addInt(value);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * If true, radio should not try to be smart about what packets to queue to
         * the phone
         * bool keep_all_packets = 101;
         * If true, we will try to capture all the packets sent on the mesh, not just the ones destined to our node.
         * bool promiscuous_mode = 102;
         * For testing it is useful sometimes to force a node to never listen to
         * particular other nodes (simulating radio out of range). All nodenums listed
         * in ignore_incoming will have packets they send droped on receive (by router.cpp)
         * </pre>
         *
         * <code>repeated uint32 ignore_incoming = 103;</code>
         * @param values The ignoreIncoming to add.
         * @return This builder for chaining.
         */
        public Builder addAllIgnoreIncoming(
            java.lang.Iterable<? extends java.lang.Integer> values) {
          ensureIgnoreIncomingIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, ignoreIncoming_);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * If true, radio should not try to be smart about what packets to queue to
         * the phone
         * bool keep_all_packets = 101;
         * If true, we will try to capture all the packets sent on the mesh, not just the ones destined to our node.
         * bool promiscuous_mode = 102;
         * For testing it is useful sometimes to force a node to never listen to
         * particular other nodes (simulating radio out of range). All nodenums listed
         * in ignore_incoming will have packets they send droped on receive (by router.cpp)
         * </pre>
         *
         * <code>repeated uint32 ignore_incoming = 103;</code>
         * @return This builder for chaining.
         */
        public Builder clearIgnoreIncoming() {
          ignoreIncoming_ = emptyIntList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
          return this;
        }

        private boolean serialpluginEnabled_ ;
        /**
         * <pre>
         * Preferences for the SerialPlugin
         * FIXME - Move this out of UserPreferences and into a section for plugin configuration.
         * </pre>
         *
         * <code>bool serialplugin_enabled = 120;</code>
         * @return The serialpluginEnabled.
         */
        @java.lang.Override
        public boolean getSerialpluginEnabled() {
          return serialpluginEnabled_;
        }
        /**
         * <pre>
         * Preferences for the SerialPlugin
         * FIXME - Move this out of UserPreferences and into a section for plugin configuration.
         * </pre>
         *
         * <code>bool serialplugin_enabled = 120;</code>
         * @param value The serialpluginEnabled to set.
         * @return This builder for chaining.
         */
        public Builder setSerialpluginEnabled(boolean value) {
          
          serialpluginEnabled_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Preferences for the SerialPlugin
         * FIXME - Move this out of UserPreferences and into a section for plugin configuration.
         * </pre>
         *
         * <code>bool serialplugin_enabled = 120;</code>
         * @return This builder for chaining.
         */
        public Builder clearSerialpluginEnabled() {
          
          serialpluginEnabled_ = false;
          onChanged();
          return this;
        }

        private boolean serialpluginEcho_ ;
        /**
         * <code>bool serialplugin_echo = 121;</code>
         * @return The serialpluginEcho.
         */
        @java.lang.Override
        public boolean getSerialpluginEcho() {
          return serialpluginEcho_;
        }
        /**
         * <code>bool serialplugin_echo = 121;</code>
         * @param value The serialpluginEcho to set.
         * @return This builder for chaining.
         */
        public Builder setSerialpluginEcho(boolean value) {
          
          serialpluginEcho_ = value;
          onChanged();
          return this;
        }
        /**
         * <code>bool serialplugin_echo = 121;</code>
         * @return This builder for chaining.
         */
        public Builder clearSerialpluginEcho() {
          
          serialpluginEcho_ = false;
          onChanged();
          return this;
        }

        private int serialpluginRxd_ ;
        /**
         * <code>uint32 serialplugin_rxd = 122;</code>
         * @return The serialpluginRxd.
         */
        @java.lang.Override
        public int getSerialpluginRxd() {
          return serialpluginRxd_;
        }
        /**
         * <code>uint32 serialplugin_rxd = 122;</code>
         * @param value The serialpluginRxd to set.
         * @return This builder for chaining.
         */
        public Builder setSerialpluginRxd(int value) {
          
          serialpluginRxd_ = value;
          onChanged();
          return this;
        }
        /**
         * <code>uint32 serialplugin_rxd = 122;</code>
         * @return This builder for chaining.
         */
        public Builder clearSerialpluginRxd() {
          
          serialpluginRxd_ = 0;
          onChanged();
          return this;
        }

        private int serialpluginTxd_ ;
        /**
         * <code>uint32 serialplugin_txd = 123;</code>
         * @return The serialpluginTxd.
         */
        @java.lang.Override
        public int getSerialpluginTxd() {
          return serialpluginTxd_;
        }
        /**
         * <code>uint32 serialplugin_txd = 123;</code>
         * @param value The serialpluginTxd to set.
         * @return This builder for chaining.
         */
        public Builder setSerialpluginTxd(int value) {
          
          serialpluginTxd_ = value;
          onChanged();
          return this;
        }
        /**
         * <code>uint32 serialplugin_txd = 123;</code>
         * @return This builder for chaining.
         */
        public Builder clearSerialpluginTxd() {
          
          serialpluginTxd_ = 0;
          onChanged();
          return this;
        }

        private int serialpluginTimeout_ ;
        /**
         * <code>uint32 serialplugin_timeout = 124;</code>
         * @return The serialpluginTimeout.
         */
        @java.lang.Override
        public int getSerialpluginTimeout() {
          return serialpluginTimeout_;
        }
        /**
         * <code>uint32 serialplugin_timeout = 124;</code>
         * @param value The serialpluginTimeout to set.
         * @return This builder for chaining.
         */
        public Builder setSerialpluginTimeout(int value) {
          
          serialpluginTimeout_ = value;
          onChanged();
          return this;
        }
        /**
         * <code>uint32 serialplugin_timeout = 124;</code>
         * @return This builder for chaining.
         */
        public Builder clearSerialpluginTimeout() {
          
          serialpluginTimeout_ = 0;
          onChanged();
          return this;
        }

        private int serialpluginMode_ ;
        /**
         * <code>uint32 serialplugin_mode = 125;</code>
         * @return The serialpluginMode.
         */
        @java.lang.Override
        public int getSerialpluginMode() {
          return serialpluginMode_;
        }
        /**
         * <code>uint32 serialplugin_mode = 125;</code>
         * @param value The serialpluginMode to set.
         * @return This builder for chaining.
         */
        public Builder setSerialpluginMode(int value) {
          
          serialpluginMode_ = value;
          onChanged();
          return this;
        }
        /**
         * <code>uint32 serialplugin_mode = 125;</code>
         * @return This builder for chaining.
         */
        public Builder clearSerialpluginMode() {
          
          serialpluginMode_ = 0;
          onChanged();
          return this;
        }

        private boolean extNotificationPluginEnabled_ ;
        /**
         * <pre>
         * Preferences for the ExternalNotificationPlugin
         * FIXME - Move this out of UserPreferences and into a section for plugin configuration.
         * </pre>
         *
         * <code>bool ext_notification_plugin_enabled = 126;</code>
         * @return The extNotificationPluginEnabled.
         */
        @java.lang.Override
        public boolean getExtNotificationPluginEnabled() {
          return extNotificationPluginEnabled_;
        }
        /**
         * <pre>
         * Preferences for the ExternalNotificationPlugin
         * FIXME - Move this out of UserPreferences and into a section for plugin configuration.
         * </pre>
         *
         * <code>bool ext_notification_plugin_enabled = 126;</code>
         * @param value The extNotificationPluginEnabled to set.
         * @return This builder for chaining.
         */
        public Builder setExtNotificationPluginEnabled(boolean value) {
          
          extNotificationPluginEnabled_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Preferences for the ExternalNotificationPlugin
         * FIXME - Move this out of UserPreferences and into a section for plugin configuration.
         * </pre>
         *
         * <code>bool ext_notification_plugin_enabled = 126;</code>
         * @return This builder for chaining.
         */
        public Builder clearExtNotificationPluginEnabled() {
          
          extNotificationPluginEnabled_ = false;
          onChanged();
          return this;
        }

        private int extNotificationPluginOutputMs_ ;
        /**
         * <code>uint32 ext_notification_plugin_output_ms = 127;</code>
         * @return The extNotificationPluginOutputMs.
         */
        @java.lang.Override
        public int getExtNotificationPluginOutputMs() {
          return extNotificationPluginOutputMs_;
        }
        /**
         * <code>uint32 ext_notification_plugin_output_ms = 127;</code>
         * @param value The extNotificationPluginOutputMs to set.
         * @return This builder for chaining.
         */
        public Builder setExtNotificationPluginOutputMs(int value) {
          
          extNotificationPluginOutputMs_ = value;
          onChanged();
          return this;
        }
        /**
         * <code>uint32 ext_notification_plugin_output_ms = 127;</code>
         * @return This builder for chaining.
         */
        public Builder clearExtNotificationPluginOutputMs() {
          
          extNotificationPluginOutputMs_ = 0;
          onChanged();
          return this;
        }

        private int extNotificationPluginOutput_ ;
        /**
         * <code>uint32 ext_notification_plugin_output = 128;</code>
         * @return The extNotificationPluginOutput.
         */
        @java.lang.Override
        public int getExtNotificationPluginOutput() {
          return extNotificationPluginOutput_;
        }
        /**
         * <code>uint32 ext_notification_plugin_output = 128;</code>
         * @param value The extNotificationPluginOutput to set.
         * @return This builder for chaining.
         */
        public Builder setExtNotificationPluginOutput(int value) {
          
          extNotificationPluginOutput_ = value;
          onChanged();
          return this;
        }
        /**
         * <code>uint32 ext_notification_plugin_output = 128;</code>
         * @return This builder for chaining.
         */
        public Builder clearExtNotificationPluginOutput() {
          
          extNotificationPluginOutput_ = 0;
          onChanged();
          return this;
        }

        private boolean extNotificationPluginActive_ ;
        /**
         * <code>bool ext_notification_plugin_active = 129;</code>
         * @return The extNotificationPluginActive.
         */
        @java.lang.Override
        public boolean getExtNotificationPluginActive() {
          return extNotificationPluginActive_;
        }
        /**
         * <code>bool ext_notification_plugin_active = 129;</code>
         * @param value The extNotificationPluginActive to set.
         * @return This builder for chaining.
         */
        public Builder setExtNotificationPluginActive(boolean value) {
          
          extNotificationPluginActive_ = value;
          onChanged();
          return this;
        }
        /**
         * <code>bool ext_notification_plugin_active = 129;</code>
         * @return This builder for chaining.
         */
        public Builder clearExtNotificationPluginActive() {
          
          extNotificationPluginActive_ = false;
          onChanged();
          return this;
        }

        private boolean extNotificationPluginAlertMessage_ ;
        /**
         * <code>bool ext_notification_plugin_alert_message = 130;</code>
         * @return The extNotificationPluginAlertMessage.
         */
        @java.lang.Override
        public boolean getExtNotificationPluginAlertMessage() {
          return extNotificationPluginAlertMessage_;
        }
        /**
         * <code>bool ext_notification_plugin_alert_message = 130;</code>
         * @param value The extNotificationPluginAlertMessage to set.
         * @return This builder for chaining.
         */
        public Builder setExtNotificationPluginAlertMessage(boolean value) {
          
          extNotificationPluginAlertMessage_ = value;
          onChanged();
          return this;
        }
        /**
         * <code>bool ext_notification_plugin_alert_message = 130;</code>
         * @return This builder for chaining.
         */
        public Builder clearExtNotificationPluginAlertMessage() {
          
          extNotificationPluginAlertMessage_ = false;
          onChanged();
          return this;
        }

        private boolean extNotificationPluginAlertBell_ ;
        /**
         * <code>bool ext_notification_plugin_alert_bell = 131;</code>
         * @return The extNotificationPluginAlertBell.
         */
        @java.lang.Override
        public boolean getExtNotificationPluginAlertBell() {
          return extNotificationPluginAlertBell_;
        }
        /**
         * <code>bool ext_notification_plugin_alert_bell = 131;</code>
         * @param value The extNotificationPluginAlertBell to set.
         * @return This builder for chaining.
         */
        public Builder setExtNotificationPluginAlertBell(boolean value) {
          
          extNotificationPluginAlertBell_ = value;
          onChanged();
          return this;
        }
        /**
         * <code>bool ext_notification_plugin_alert_bell = 131;</code>
         * @return This builder for chaining.
         */
        public Builder clearExtNotificationPluginAlertBell() {
          
          extNotificationPluginAlertBell_ = false;
          onChanged();
          return this;
        }

        private boolean rangeTestPluginEnabled_ ;
        /**
         * <pre>
         *Preferences for the RangeTestPlugin
         * FIXME - Move this out of UserPreferences and into a section for plugin configuration.
         * </pre>
         *
         * <code>bool range_test_plugin_enabled = 132;</code>
         * @return The rangeTestPluginEnabled.
         */
        @java.lang.Override
        public boolean getRangeTestPluginEnabled() {
          return rangeTestPluginEnabled_;
        }
        /**
         * <pre>
         *Preferences for the RangeTestPlugin
         * FIXME - Move this out of UserPreferences and into a section for plugin configuration.
         * </pre>
         *
         * <code>bool range_test_plugin_enabled = 132;</code>
         * @param value The rangeTestPluginEnabled to set.
         * @return This builder for chaining.
         */
        public Builder setRangeTestPluginEnabled(boolean value) {
          
          rangeTestPluginEnabled_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         *Preferences for the RangeTestPlugin
         * FIXME - Move this out of UserPreferences and into a section for plugin configuration.
         * </pre>
         *
         * <code>bool range_test_plugin_enabled = 132;</code>
         * @return This builder for chaining.
         */
        public Builder clearRangeTestPluginEnabled() {
          
          rangeTestPluginEnabled_ = false;
          onChanged();
          return this;
        }

        private int rangeTestPluginSender_ ;
        /**
         * <code>uint32 range_test_plugin_sender = 133;</code>
         * @return The rangeTestPluginSender.
         */
        @java.lang.Override
        public int getRangeTestPluginSender() {
          return rangeTestPluginSender_;
        }
        /**
         * <code>uint32 range_test_plugin_sender = 133;</code>
         * @param value The rangeTestPluginSender to set.
         * @return This builder for chaining.
         */
        public Builder setRangeTestPluginSender(int value) {
          
          rangeTestPluginSender_ = value;
          onChanged();
          return this;
        }
        /**
         * <code>uint32 range_test_plugin_sender = 133;</code>
         * @return This builder for chaining.
         */
        public Builder clearRangeTestPluginSender() {
          
          rangeTestPluginSender_ = 0;
          onChanged();
          return this;
        }

        private boolean rangeTestPluginSave_ ;
        /**
         * <code>bool range_test_plugin_save = 134;</code>
         * @return The rangeTestPluginSave.
         */
        @java.lang.Override
        public boolean getRangeTestPluginSave() {
          return rangeTestPluginSave_;
        }
        /**
         * <code>bool range_test_plugin_save = 134;</code>
         * @param value The rangeTestPluginSave to set.
         * @return This builder for chaining.
         */
        public Builder setRangeTestPluginSave(boolean value) {
          
          rangeTestPluginSave_ = value;
          onChanged();
          return this;
        }
        /**
         * <code>bool range_test_plugin_save = 134;</code>
         * @return This builder for chaining.
         */
        public Builder clearRangeTestPluginSave() {
          
          rangeTestPluginSave_ = false;
          onChanged();
          return this;
        }

        private boolean storeForwardPluginEnabled_ ;
        /**
         * <pre>
         * Preferences for the StoreForwardPlugin
         *FIXME - Move this out of UserPreferences and into a section for plugin configuration. (was 136)
         * </pre>
         *
         * <code>bool store_forward_plugin_enabled = 148;</code>
         * @return The storeForwardPluginEnabled.
         */
        @java.lang.Override
        public boolean getStoreForwardPluginEnabled() {
          return storeForwardPluginEnabled_;
        }
        /**
         * <pre>
         * Preferences for the StoreForwardPlugin
         *FIXME - Move this out of UserPreferences and into a section for plugin configuration. (was 136)
         * </pre>
         *
         * <code>bool store_forward_plugin_enabled = 148;</code>
         * @param value The storeForwardPluginEnabled to set.
         * @return This builder for chaining.
         */
        public Builder setStoreForwardPluginEnabled(boolean value) {
          
          storeForwardPluginEnabled_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Preferences for the StoreForwardPlugin
         *FIXME - Move this out of UserPreferences and into a section for plugin configuration. (was 136)
         * </pre>
         *
         * <code>bool store_forward_plugin_enabled = 148;</code>
         * @return This builder for chaining.
         */
        public Builder clearStoreForwardPluginEnabled() {
          
          storeForwardPluginEnabled_ = false;
          onChanged();
          return this;
        }

        private int storeForwardPluginRecords_ ;
        /**
         * <code>uint32 store_forward_plugin_records = 137;</code>
         * @return The storeForwardPluginRecords.
         */
        @java.lang.Override
        public int getStoreForwardPluginRecords() {
          return storeForwardPluginRecords_;
        }
        /**
         * <code>uint32 store_forward_plugin_records = 137;</code>
         * @param value The storeForwardPluginRecords to set.
         * @return This builder for chaining.
         */
        public Builder setStoreForwardPluginRecords(int value) {
          
          storeForwardPluginRecords_ = value;
          onChanged();
          return this;
        }
        /**
         * <code>uint32 store_forward_plugin_records = 137;</code>
         * @return This builder for chaining.
         */
        public Builder clearStoreForwardPluginRecords() {
          
          storeForwardPluginRecords_ = 0;
          onChanged();
          return this;
        }

        private boolean environmentalMeasurementPluginMeasurementEnabled_ ;
        /**
         * <pre>
         * Preferences for the EnvironmentalMeasurement Plugin
         * FIXME - Move this out of UserPreferences and into a section for plugin configuration.
         * Enable/Disable the environmental measurement plugin measurement collection
         * </pre>
         *
         * <code>bool environmental_measurement_plugin_measurement_enabled = 140;</code>
         * @return The environmentalMeasurementPluginMeasurementEnabled.
         */
        @java.lang.Override
        public boolean getEnvironmentalMeasurementPluginMeasurementEnabled() {
          return environmentalMeasurementPluginMeasurementEnabled_;
        }
        /**
         * <pre>
         * Preferences for the EnvironmentalMeasurement Plugin
         * FIXME - Move this out of UserPreferences and into a section for plugin configuration.
         * Enable/Disable the environmental measurement plugin measurement collection
         * </pre>
         *
         * <code>bool environmental_measurement_plugin_measurement_enabled = 140;</code>
         * @param value The environmentalMeasurementPluginMeasurementEnabled to set.
         * @return This builder for chaining.
         */
        public Builder setEnvironmentalMeasurementPluginMeasurementEnabled(boolean value) {
          
          environmentalMeasurementPluginMeasurementEnabled_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Preferences for the EnvironmentalMeasurement Plugin
         * FIXME - Move this out of UserPreferences and into a section for plugin configuration.
         * Enable/Disable the environmental measurement plugin measurement collection
         * </pre>
         *
         * <code>bool environmental_measurement_plugin_measurement_enabled = 140;</code>
         * @return This builder for chaining.
         */
        public Builder clearEnvironmentalMeasurementPluginMeasurementEnabled() {
          
          environmentalMeasurementPluginMeasurementEnabled_ = false;
          onChanged();
          return this;
        }

        private boolean environmentalMeasurementPluginScreenEnabled_ ;
        /**
         * <pre>
         * Enable/Disable the environmental measurement plugin on-device display
         * </pre>
         *
         * <code>bool environmental_measurement_plugin_screen_enabled = 141;</code>
         * @return The environmentalMeasurementPluginScreenEnabled.
         */
        @java.lang.Override
        public boolean getEnvironmentalMeasurementPluginScreenEnabled() {
          return environmentalMeasurementPluginScreenEnabled_;
        }
        /**
         * <pre>
         * Enable/Disable the environmental measurement plugin on-device display
         * </pre>
         *
         * <code>bool environmental_measurement_plugin_screen_enabled = 141;</code>
         * @param value The environmentalMeasurementPluginScreenEnabled to set.
         * @return This builder for chaining.
         */
        public Builder setEnvironmentalMeasurementPluginScreenEnabled(boolean value) {
          
          environmentalMeasurementPluginScreenEnabled_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Enable/Disable the environmental measurement plugin on-device display
         * </pre>
         *
         * <code>bool environmental_measurement_plugin_screen_enabled = 141;</code>
         * @return This builder for chaining.
         */
        public Builder clearEnvironmentalMeasurementPluginScreenEnabled() {
          
          environmentalMeasurementPluginScreenEnabled_ = false;
          onChanged();
          return this;
        }

        private int environmentalMeasurementPluginReadErrorCountThreshold_ ;
        /**
         * <pre>
         * Sometimes sensor reads can fail.
         * If this happens, we will retry a configurable number of attempts,
         * each attempt will be delayed by the minimum required refresh rate for that sensor
         * </pre>
         *
         * <code>uint32 environmental_measurement_plugin_read_error_count_threshold = 142;</code>
         * @return The environmentalMeasurementPluginReadErrorCountThreshold.
         */
        @java.lang.Override
        public int getEnvironmentalMeasurementPluginReadErrorCountThreshold() {
          return environmentalMeasurementPluginReadErrorCountThreshold_;
        }
        /**
         * <pre>
         * Sometimes sensor reads can fail.
         * If this happens, we will retry a configurable number of attempts,
         * each attempt will be delayed by the minimum required refresh rate for that sensor
         * </pre>
         *
         * <code>uint32 environmental_measurement_plugin_read_error_count_threshold = 142;</code>
         * @param value The environmentalMeasurementPluginReadErrorCountThreshold to set.
         * @return This builder for chaining.
         */
        public Builder setEnvironmentalMeasurementPluginReadErrorCountThreshold(int value) {
          
          environmentalMeasurementPluginReadErrorCountThreshold_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Sometimes sensor reads can fail.
         * If this happens, we will retry a configurable number of attempts,
         * each attempt will be delayed by the minimum required refresh rate for that sensor
         * </pre>
         *
         * <code>uint32 environmental_measurement_plugin_read_error_count_threshold = 142;</code>
         * @return This builder for chaining.
         */
        public Builder clearEnvironmentalMeasurementPluginReadErrorCountThreshold() {
          
          environmentalMeasurementPluginReadErrorCountThreshold_ = 0;
          onChanged();
          return this;
        }

        private int environmentalMeasurementPluginUpdateInterval_ ;
        /**
         * <pre>
         * Interval in seconds of how often we should try to send our 
         * measurements to the mesh
         * </pre>
         *
         * <code>uint32 environmental_measurement_plugin_update_interval = 143;</code>
         * @return The environmentalMeasurementPluginUpdateInterval.
         */
        @java.lang.Override
        public int getEnvironmentalMeasurementPluginUpdateInterval() {
          return environmentalMeasurementPluginUpdateInterval_;
        }
        /**
         * <pre>
         * Interval in seconds of how often we should try to send our 
         * measurements to the mesh
         * </pre>
         *
         * <code>uint32 environmental_measurement_plugin_update_interval = 143;</code>
         * @param value The environmentalMeasurementPluginUpdateInterval to set.
         * @return This builder for chaining.
         */
        public Builder setEnvironmentalMeasurementPluginUpdateInterval(int value) {
          
          environmentalMeasurementPluginUpdateInterval_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Interval in seconds of how often we should try to send our 
         * measurements to the mesh
         * </pre>
         *
         * <code>uint32 environmental_measurement_plugin_update_interval = 143;</code>
         * @return This builder for chaining.
         */
        public Builder clearEnvironmentalMeasurementPluginUpdateInterval() {
          
          environmentalMeasurementPluginUpdateInterval_ = 0;
          onChanged();
          return this;
        }

        private int environmentalMeasurementPluginRecoveryInterval_ ;
        /**
         * <pre>
         * Sometimes we can end up with more than read_error_count_threshold failures.
         * In this case, we will stop trying to read from the sensor for a while.
         * Wait this long until trying to read from the sensor again
         * </pre>
         *
         * <code>uint32 environmental_measurement_plugin_recovery_interval = 144;</code>
         * @return The environmentalMeasurementPluginRecoveryInterval.
         */
        @java.lang.Override
        public int getEnvironmentalMeasurementPluginRecoveryInterval() {
          return environmentalMeasurementPluginRecoveryInterval_;
        }
        /**
         * <pre>
         * Sometimes we can end up with more than read_error_count_threshold failures.
         * In this case, we will stop trying to read from the sensor for a while.
         * Wait this long until trying to read from the sensor again
         * </pre>
         *
         * <code>uint32 environmental_measurement_plugin_recovery_interval = 144;</code>
         * @param value The environmentalMeasurementPluginRecoveryInterval to set.
         * @return This builder for chaining.
         */
        public Builder setEnvironmentalMeasurementPluginRecoveryInterval(int value) {
          
          environmentalMeasurementPluginRecoveryInterval_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Sometimes we can end up with more than read_error_count_threshold failures.
         * In this case, we will stop trying to read from the sensor for a while.
         * Wait this long until trying to read from the sensor again
         * </pre>
         *
         * <code>uint32 environmental_measurement_plugin_recovery_interval = 144;</code>
         * @return This builder for chaining.
         */
        public Builder clearEnvironmentalMeasurementPluginRecoveryInterval() {
          
          environmentalMeasurementPluginRecoveryInterval_ = 0;
          onChanged();
          return this;
        }

        private boolean environmentalMeasurementPluginDisplayFarenheit_ ;
        /**
         * <pre>
         * We'll always read the sensor in Celsius, but sometimes we might want to
         * display the results in Farenheit as a "user preference".
         * </pre>
         *
         * <code>bool environmental_measurement_plugin_display_farenheit = 145;</code>
         * @return The environmentalMeasurementPluginDisplayFarenheit.
         */
        @java.lang.Override
        public boolean getEnvironmentalMeasurementPluginDisplayFarenheit() {
          return environmentalMeasurementPluginDisplayFarenheit_;
        }
        /**
         * <pre>
         * We'll always read the sensor in Celsius, but sometimes we might want to
         * display the results in Farenheit as a "user preference".
         * </pre>
         *
         * <code>bool environmental_measurement_plugin_display_farenheit = 145;</code>
         * @param value The environmentalMeasurementPluginDisplayFarenheit to set.
         * @return This builder for chaining.
         */
        public Builder setEnvironmentalMeasurementPluginDisplayFarenheit(boolean value) {
          
          environmentalMeasurementPluginDisplayFarenheit_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * We'll always read the sensor in Celsius, but sometimes we might want to
         * display the results in Farenheit as a "user preference".
         * </pre>
         *
         * <code>bool environmental_measurement_plugin_display_farenheit = 145;</code>
         * @return This builder for chaining.
         */
        public Builder clearEnvironmentalMeasurementPluginDisplayFarenheit() {
          
          environmentalMeasurementPluginDisplayFarenheit_ = false;
          onChanged();
          return this;
        }

        private int environmentalMeasurementPluginSensorType_ = 0;
        /**
         * <pre>
         * Specify the sensor type
         * </pre>
         *
         * <code>.RadioConfig.UserPreferences.EnvironmentalMeasurementSensorType environmental_measurement_plugin_sensor_type = 146;</code>
         * @return The enum numeric value on the wire for environmentalMeasurementPluginSensorType.
         */
        @java.lang.Override public int getEnvironmentalMeasurementPluginSensorTypeValue() {
          return environmentalMeasurementPluginSensorType_;
        }
        /**
         * <pre>
         * Specify the sensor type
         * </pre>
         *
         * <code>.RadioConfig.UserPreferences.EnvironmentalMeasurementSensorType environmental_measurement_plugin_sensor_type = 146;</code>
         * @param value The enum numeric value on the wire for environmentalMeasurementPluginSensorType to set.
         * @return This builder for chaining.
         */
        public Builder setEnvironmentalMeasurementPluginSensorTypeValue(int value) {
          
          environmentalMeasurementPluginSensorType_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Specify the sensor type
         * </pre>
         *
         * <code>.RadioConfig.UserPreferences.EnvironmentalMeasurementSensorType environmental_measurement_plugin_sensor_type = 146;</code>
         * @return The environmentalMeasurementPluginSensorType.
         */
        @java.lang.Override
        public com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences.EnvironmentalMeasurementSensorType getEnvironmentalMeasurementPluginSensorType() {
          @SuppressWarnings("deprecation")
          com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences.EnvironmentalMeasurementSensorType result = com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences.EnvironmentalMeasurementSensorType.valueOf(environmentalMeasurementPluginSensorType_);
          return result == null ? com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences.EnvironmentalMeasurementSensorType.UNRECOGNIZED : result;
        }
        /**
         * <pre>
         * Specify the sensor type
         * </pre>
         *
         * <code>.RadioConfig.UserPreferences.EnvironmentalMeasurementSensorType environmental_measurement_plugin_sensor_type = 146;</code>
         * @param value The environmentalMeasurementPluginSensorType to set.
         * @return This builder for chaining.
         */
        public Builder setEnvironmentalMeasurementPluginSensorType(com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences.EnvironmentalMeasurementSensorType value) {
          if (value == null) {
            throw new NullPointerException();
          }
          
          environmentalMeasurementPluginSensorType_ = value.getNumber();
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Specify the sensor type
         * </pre>
         *
         * <code>.RadioConfig.UserPreferences.EnvironmentalMeasurementSensorType environmental_measurement_plugin_sensor_type = 146;</code>
         * @return This builder for chaining.
         */
        public Builder clearEnvironmentalMeasurementPluginSensorType() {
          
          environmentalMeasurementPluginSensorType_ = 0;
          onChanged();
          return this;
        }

        private int environmentalMeasurementPluginSensorPin_ ;
        /**
         * <pre>
         * Specify the peferred GPIO Pin for sensor readings
         * </pre>
         *
         * <code>uint32 environmental_measurement_plugin_sensor_pin = 147;</code>
         * @return The environmentalMeasurementPluginSensorPin.
         */
        @java.lang.Override
        public int getEnvironmentalMeasurementPluginSensorPin() {
          return environmentalMeasurementPluginSensorPin_;
        }
        /**
         * <pre>
         * Specify the peferred GPIO Pin for sensor readings
         * </pre>
         *
         * <code>uint32 environmental_measurement_plugin_sensor_pin = 147;</code>
         * @param value The environmentalMeasurementPluginSensorPin to set.
         * @return This builder for chaining.
         */
        public Builder setEnvironmentalMeasurementPluginSensorPin(int value) {
          
          environmentalMeasurementPluginSensorPin_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Specify the peferred GPIO Pin for sensor readings
         * </pre>
         *
         * <code>uint32 environmental_measurement_plugin_sensor_pin = 147;</code>
         * @return This builder for chaining.
         */
        public Builder clearEnvironmentalMeasurementPluginSensorPin() {
          
          environmentalMeasurementPluginSensorPin_ = 0;
          onChanged();
          return this;
        }
        @java.lang.Override
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFields(unknownFields);
        }

        @java.lang.Override
        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:RadioConfig.UserPreferences)
      }

      // @@protoc_insertion_point(class_scope:RadioConfig.UserPreferences)
      private static final com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences();
      }

      public static com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<UserPreferences>
          PARSER = new com.google.protobuf.AbstractParser<UserPreferences>() {
        @java.lang.Override
        public UserPreferences parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return new UserPreferences(input, extensionRegistry);
        }
      };

      public static com.google.protobuf.Parser<UserPreferences> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<UserPreferences> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    public static final int PREFERENCES_FIELD_NUMBER = 1;
    private com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences preferences_;
    /**
     * <code>.RadioConfig.UserPreferences preferences = 1;</code>
     * @return Whether the preferences field is set.
     */
    @java.lang.Override
    public boolean hasPreferences() {
      return preferences_ != null;
    }
    /**
     * <code>.RadioConfig.UserPreferences preferences = 1;</code>
     * @return The preferences.
     */
    @java.lang.Override
    public com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences getPreferences() {
      return preferences_ == null ? com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences.getDefaultInstance() : preferences_;
    }
    /**
     * <code>.RadioConfig.UserPreferences preferences = 1;</code>
     */
    @java.lang.Override
    public com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferencesOrBuilder getPreferencesOrBuilder() {
      return getPreferences();
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (preferences_ != null) {
        output.writeMessage(1, getPreferences());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (preferences_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getPreferences());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof com.geeksville.mesh.RadioConfigProtos.RadioConfig)) {
        return super.equals(obj);
      }
      com.geeksville.mesh.RadioConfigProtos.RadioConfig other = (com.geeksville.mesh.RadioConfigProtos.RadioConfig) obj;

      if (hasPreferences() != other.hasPreferences()) return false;
      if (hasPreferences()) {
        if (!getPreferences()
            .equals(other.getPreferences())) return false;
      }
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasPreferences()) {
        hash = (37 * hash) + PREFERENCES_FIELD_NUMBER;
        hash = (53 * hash) + getPreferences().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.geeksville.mesh.RadioConfigProtos.RadioConfig parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.geeksville.mesh.RadioConfigProtos.RadioConfig parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.geeksville.mesh.RadioConfigProtos.RadioConfig parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.geeksville.mesh.RadioConfigProtos.RadioConfig parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.geeksville.mesh.RadioConfigProtos.RadioConfig parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.geeksville.mesh.RadioConfigProtos.RadioConfig parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.geeksville.mesh.RadioConfigProtos.RadioConfig parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static com.geeksville.mesh.RadioConfigProtos.RadioConfig parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.geeksville.mesh.RadioConfigProtos.RadioConfig parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static com.geeksville.mesh.RadioConfigProtos.RadioConfig parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.geeksville.mesh.RadioConfigProtos.RadioConfig parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static com.geeksville.mesh.RadioConfigProtos.RadioConfig parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.geeksville.mesh.RadioConfigProtos.RadioConfig prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * The entire set of user settable/readable settings for our radio device.
     * Includes both the current channel settings and any preferences the user has
     * set for behavior of their node
     * </pre>
     *
     * Protobuf type {@code RadioConfig}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:RadioConfig)
        com.geeksville.mesh.RadioConfigProtos.RadioConfigOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.geeksville.mesh.RadioConfigProtos.internal_static_RadioConfig_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.geeksville.mesh.RadioConfigProtos.internal_static_RadioConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.geeksville.mesh.RadioConfigProtos.RadioConfig.class, com.geeksville.mesh.RadioConfigProtos.RadioConfig.Builder.class);
      }

      // Construct using com.geeksville.mesh.RadioConfigProtos.RadioConfig.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (preferencesBuilder_ == null) {
          preferences_ = null;
        } else {
          preferences_ = null;
          preferencesBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return com.geeksville.mesh.RadioConfigProtos.internal_static_RadioConfig_descriptor;
      }

      @java.lang.Override
      public com.geeksville.mesh.RadioConfigProtos.RadioConfig getDefaultInstanceForType() {
        return com.geeksville.mesh.RadioConfigProtos.RadioConfig.getDefaultInstance();
      }

      @java.lang.Override
      public com.geeksville.mesh.RadioConfigProtos.RadioConfig build() {
        com.geeksville.mesh.RadioConfigProtos.RadioConfig result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public com.geeksville.mesh.RadioConfigProtos.RadioConfig buildPartial() {
        com.geeksville.mesh.RadioConfigProtos.RadioConfig result = new com.geeksville.mesh.RadioConfigProtos.RadioConfig(this);
        if (preferencesBuilder_ == null) {
          result.preferences_ = preferences_;
        } else {
          result.preferences_ = preferencesBuilder_.build();
        }
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.geeksville.mesh.RadioConfigProtos.RadioConfig) {
          return mergeFrom((com.geeksville.mesh.RadioConfigProtos.RadioConfig)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(com.geeksville.mesh.RadioConfigProtos.RadioConfig other) {
        if (other == com.geeksville.mesh.RadioConfigProtos.RadioConfig.getDefaultInstance()) return this;
        if (other.hasPreferences()) {
          mergePreferences(other.getPreferences());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        com.geeksville.mesh.RadioConfigProtos.RadioConfig parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (com.geeksville.mesh.RadioConfigProtos.RadioConfig) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences preferences_;
      private com.google.protobuf.SingleFieldBuilderV3<
          com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences, com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences.Builder, com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferencesOrBuilder> preferencesBuilder_;
      /**
       * <code>.RadioConfig.UserPreferences preferences = 1;</code>
       * @return Whether the preferences field is set.
       */
      public boolean hasPreferences() {
        return preferencesBuilder_ != null || preferences_ != null;
      }
      /**
       * <code>.RadioConfig.UserPreferences preferences = 1;</code>
       * @return The preferences.
       */
      public com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences getPreferences() {
        if (preferencesBuilder_ == null) {
          return preferences_ == null ? com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences.getDefaultInstance() : preferences_;
        } else {
          return preferencesBuilder_.getMessage();
        }
      }
      /**
       * <code>.RadioConfig.UserPreferences preferences = 1;</code>
       */
      public Builder setPreferences(com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences value) {
        if (preferencesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          preferences_ = value;
          onChanged();
        } else {
          preferencesBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <code>.RadioConfig.UserPreferences preferences = 1;</code>
       */
      public Builder setPreferences(
          com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences.Builder builderForValue) {
        if (preferencesBuilder_ == null) {
          preferences_ = builderForValue.build();
          onChanged();
        } else {
          preferencesBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <code>.RadioConfig.UserPreferences preferences = 1;</code>
       */
      public Builder mergePreferences(com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences value) {
        if (preferencesBuilder_ == null) {
          if (preferences_ != null) {
            preferences_ =
              com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences.newBuilder(preferences_).mergeFrom(value).buildPartial();
          } else {
            preferences_ = value;
          }
          onChanged();
        } else {
          preferencesBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <code>.RadioConfig.UserPreferences preferences = 1;</code>
       */
      public Builder clearPreferences() {
        if (preferencesBuilder_ == null) {
          preferences_ = null;
          onChanged();
        } else {
          preferences_ = null;
          preferencesBuilder_ = null;
        }

        return this;
      }
      /**
       * <code>.RadioConfig.UserPreferences preferences = 1;</code>
       */
      public com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences.Builder getPreferencesBuilder() {
        
        onChanged();
        return getPreferencesFieldBuilder().getBuilder();
      }
      /**
       * <code>.RadioConfig.UserPreferences preferences = 1;</code>
       */
      public com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferencesOrBuilder getPreferencesOrBuilder() {
        if (preferencesBuilder_ != null) {
          return preferencesBuilder_.getMessageOrBuilder();
        } else {
          return preferences_ == null ?
              com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences.getDefaultInstance() : preferences_;
        }
      }
      /**
       * <code>.RadioConfig.UserPreferences preferences = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences, com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences.Builder, com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferencesOrBuilder> 
          getPreferencesFieldBuilder() {
        if (preferencesBuilder_ == null) {
          preferencesBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences, com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferences.Builder, com.geeksville.mesh.RadioConfigProtos.RadioConfig.UserPreferencesOrBuilder>(
                  getPreferences(),
                  getParentForChildren(),
                  isClean());
          preferences_ = null;
        }
        return preferencesBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:RadioConfig)
    }

    // @@protoc_insertion_point(class_scope:RadioConfig)
    private static final com.geeksville.mesh.RadioConfigProtos.RadioConfig DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new com.geeksville.mesh.RadioConfigProtos.RadioConfig();
    }

    public static com.geeksville.mesh.RadioConfigProtos.RadioConfig getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<RadioConfig>
        PARSER = new com.google.protobuf.AbstractParser<RadioConfig>() {
      @java.lang.Override
      public RadioConfig parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new RadioConfig(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<RadioConfig> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<RadioConfig> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public com.geeksville.mesh.RadioConfigProtos.RadioConfig getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_RadioConfig_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_RadioConfig_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_RadioConfig_UserPreferences_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_RadioConfig_UserPreferences_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n\021radioconfig.proto\"\214\020\n\013RadioConfig\0221\n\013p" +
      "references\030\001 \001(\0132\034.RadioConfig.UserPrefe" +
      "rences\032\311\017\n\017UserPreferences\022\037\n\027position_b" +
      "roadcast_secs\030\001 \001(\r\022\033\n\023send_owner_interv" +
      "al\030\002 \001(\r\022\033\n\023wait_bluetooth_secs\030\004 \001(\r\022\026\n" +
      "\016screen_on_secs\030\005 \001(\r\022\032\n\022phone_timeout_s" +
      "ecs\030\006 \001(\r\022\035\n\025phone_sds_timeout_sec\030\007 \001(\r" +
      "\022\035\n\025mesh_sds_timeout_secs\030\010 \001(\r\022\020\n\010sds_s" +
      "ecs\030\t \001(\r\022\017\n\007ls_secs\030\n \001(\r\022\025\n\rmin_wake_s" +
      "ecs\030\013 \001(\r\022\021\n\twifi_ssid\030\014 \001(\t\022\025\n\rwifi_pas" +
      "sword\030\r \001(\t\022\024\n\014wifi_ap_mode\030\016 \001(\010\022\033\n\006reg" +
      "ion\030\017 \001(\0162\013.RegionCode\022&\n\016charge_current" +
      "\030\020 \001(\0162\016.ChargeCurrent\022\021\n\tis_router\030% \001(" +
      "\010\022\024\n\014is_low_power\030& \001(\010\022\026\n\016fixed_positio" +
      "n\030\' \001(\010\022\027\n\017serial_disabled\030( \001(\010\022(\n\016loca" +
      "tion_share\030  \001(\0162\020.LocationSharing\022$\n\rgp" +
      "s_operation\030! \001(\0162\r.GpsOperation\022\033\n\023gps_" +
      "update_interval\030\" \001(\r\022\030\n\020gps_attempt_tim" +
      "e\030$ \001(\r\022\030\n\020frequency_offset\030) \001(\002\022\023\n\013mqt" +
      "t_server\030* \001(\t\022\025\n\rmqtt_disabled\030+ \001(\010\022\025\n" +
      "\rfactory_reset\030d \001(\010\022\031\n\021debug_log_enable" +
      "d\030e \001(\010\022\027\n\017ignore_incoming\030g \003(\r\022\034\n\024seri" +
      "alplugin_enabled\030x \001(\010\022\031\n\021serialplugin_e" +
      "cho\030y \001(\010\022\030\n\020serialplugin_rxd\030z \001(\r\022\030\n\020s" +
      "erialplugin_txd\030{ \001(\r\022\034\n\024serialplugin_ti" +
      "meout\030| \001(\r\022\031\n\021serialplugin_mode\030} \001(\r\022\'" +
      "\n\037ext_notification_plugin_enabled\030~ \001(\010\022" +
      ")\n!ext_notification_plugin_output_ms\030\177 \001" +
      "(\r\022\'\n\036ext_notification_plugin_output\030\200\001 " +
      "\001(\r\022\'\n\036ext_notification_plugin_active\030\201\001" +
      " \001(\010\022.\n%ext_notification_plugin_alert_me" +
      "ssage\030\202\001 \001(\010\022+\n\"ext_notification_plugin_" +
      "alert_bell\030\203\001 \001(\010\022\"\n\031range_test_plugin_e" +
      "nabled\030\204\001 \001(\010\022!\n\030range_test_plugin_sende" +
      "r\030\205\001 \001(\r\022\037\n\026range_test_plugin_save\030\206\001 \001(" +
      "\010\022%\n\034store_forward_plugin_enabled\030\224\001 \001(\010" +
      "\022%\n\034store_forward_plugin_records\030\211\001 \001(\r\022" +
      "=\n4environmental_measurement_plugin_meas" +
      "urement_enabled\030\214\001 \001(\010\0228\n/environmental_" +
      "measurement_plugin_screen_enabled\030\215\001 \001(\010" +
      "\022D\n;environmental_measurement_plugin_rea" +
      "d_error_count_threshold\030\216\001 \001(\r\0229\n0enviro" +
      "nmental_measurement_plugin_update_interv" +
      "al\030\217\001 \001(\r\022;\n2environmental_measurement_p" +
      "lugin_recovery_interval\030\220\001 \001(\r\022;\n2enviro" +
      "nmental_measurement_plugin_display_faren" +
      "heit\030\221\001 \001(\010\022v\n,environmental_measurement" +
      "_plugin_sensor_type\030\222\001 \001(\0162?.RadioConfig" +
      ".UserPreferences.EnvironmentalMeasuremen" +
      "tSensorType\0224\n+environmental_measurement" +
      "_plugin_sensor_pin\030\223\001 \001(\r\"/\n\"Environment" +
      "alMeasurementSensorType\022\t\n\005DHT11\020\000J\006\010\210\001\020" +
      "\211\001*f\n\nRegionCode\022\t\n\005Unset\020\000\022\006\n\002US\020\001\022\t\n\005E" +
      "U433\020\002\022\t\n\005EU865\020\003\022\006\n\002CN\020\004\022\006\n\002JP\020\005\022\007\n\003ANZ" +
      "\020\006\022\006\n\002KR\020\007\022\006\n\002TW\020\010\022\006\n\002RU\020\t*\321\001\n\rChargeCur" +
      "rent\022\013\n\007MAUnset\020\000\022\t\n\005MA100\020\001\022\t\n\005MA190\020\002\022" +
      "\t\n\005MA280\020\003\022\t\n\005MA360\020\004\022\t\n\005MA450\020\005\022\t\n\005MA55" +
      "0\020\006\022\t\n\005MA630\020\007\022\t\n\005MA700\020\010\022\t\n\005MA780\020\t\022\t\n\005" +
      "MA880\020\n\022\t\n\005MA960\020\013\022\n\n\006MA1000\020\014\022\n\n\006MA1080" +
      "\020\r\022\n\n\006MA1160\020\016\022\n\n\006MA1240\020\017\022\n\n\006MA1320\020\020*j" +
      "\n\014GpsOperation\022\016\n\nGpsOpUnset\020\000\022\023\n\017GpsOpS" +
      "tationary\020\001\022\017\n\013GpsOpMobile\020\002\022\021\n\rGpsOpTim" +
      "eOnly\020\003\022\021\n\rGpsOpDisabled\020\004*@\n\017LocationSh" +
      "aring\022\014\n\010LocUnset\020\000\022\016\n\nLocEnabled\020\001\022\017\n\013L" +
      "ocDisabled\020\002BM\n\023com.geeksville.meshB\021Rad" +
      "ioConfigProtosH\003Z!github.com/meshtastic/" +
      "gomeshprotob\006proto3"
    };
    descriptor = com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
        });
    internal_static_RadioConfig_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_RadioConfig_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_RadioConfig_descriptor,
        new java.lang.String[] { "Preferences", });
    internal_static_RadioConfig_UserPreferences_descriptor =
      internal_static_RadioConfig_descriptor.getNestedTypes().get(0);
    internal_static_RadioConfig_UserPreferences_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_RadioConfig_UserPreferences_descriptor,
        new java.lang.String[] { "PositionBroadcastSecs", "SendOwnerInterval", "WaitBluetoothSecs", "ScreenOnSecs", "PhoneTimeoutSecs", "PhoneSdsTimeoutSec", "MeshSdsTimeoutSecs", "SdsSecs", "LsSecs", "MinWakeSecs", "WifiSsid", "WifiPassword", "WifiApMode", "Region", "ChargeCurrent", "IsRouter", "IsLowPower", "FixedPosition", "SerialDisabled", "LocationShare", "GpsOperation", "GpsUpdateInterval", "GpsAttemptTime", "FrequencyOffset", "MqttServer", "MqttDisabled", "FactoryReset", "DebugLogEnabled", "IgnoreIncoming", "SerialpluginEnabled", "SerialpluginEcho", "SerialpluginRxd", "SerialpluginTxd", "SerialpluginTimeout", "SerialpluginMode", "ExtNotificationPluginEnabled", "ExtNotificationPluginOutputMs", "ExtNotificationPluginOutput", "ExtNotificationPluginActive", "ExtNotificationPluginAlertMessage", "ExtNotificationPluginAlertBell", "RangeTestPluginEnabled", "RangeTestPluginSender", "RangeTestPluginSave", "StoreForwardPluginEnabled", "StoreForwardPluginRecords", "EnvironmentalMeasurementPluginMeasurementEnabled", "EnvironmentalMeasurementPluginScreenEnabled", "EnvironmentalMeasurementPluginReadErrorCountThreshold", "EnvironmentalMeasurementPluginUpdateInterval", "EnvironmentalMeasurementPluginRecoveryInterval", "EnvironmentalMeasurementPluginDisplayFarenheit", "EnvironmentalMeasurementPluginSensorType", "EnvironmentalMeasurementPluginSensorPin", });
  }

  // @@protoc_insertion_point(outer_class_scope)
}
